// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/fachebot/sol-grid-bot/internal/ent/grid"
	"github.com/fachebot/sol-grid-bot/internal/ent/order"
	"github.com/fachebot/sol-grid-bot/internal/ent/predicate"
	"github.com/fachebot/sol-grid-bot/internal/ent/settings"
	"github.com/fachebot/sol-grid-bot/internal/ent/strategy"
	"github.com/fachebot/sol-grid-bot/internal/ent/wallet"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGrid     = "Grid"
	TypeOrder    = "Order"
	TypeSettings = "Settings"
	TypeStrategy = "Strategy"
	TypeWallet   = "Wallet"
)

// GridMutation represents an operation that mutates the Grid nodes in the graph.
type GridMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	guid          *string
	account       *string
	token         *string
	symbol        *string
	strategyId    *string
	gridNumber    *int
	addgridNumber *int
	orderPrice    *decimal.Decimal
	finalPrice    *decimal.Decimal
	amount        *decimal.Decimal
	quantity      *decimal.Decimal
	status        *grid.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Grid, error)
	predicates    []predicate.Grid
}

var _ ent.Mutation = (*GridMutation)(nil)

// gridOption allows management of the mutation configuration using functional options.
type gridOption func(*GridMutation)

// newGridMutation creates new mutation for the Grid entity.
func newGridMutation(c config, op Op, opts ...gridOption) *GridMutation {
	m := &GridMutation{
		config:        c,
		op:            op,
		typ:           TypeGrid,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGridID sets the ID field of the mutation.
func withGridID(id int) gridOption {
	return func(m *GridMutation) {
		var (
			err   error
			once  sync.Once
			value *Grid
		)
		m.oldValue = func(ctx context.Context) (*Grid, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grid.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrid sets the old Grid of the mutation.
func withGrid(node *Grid) gridOption {
	return func(m *GridMutation) {
		m.oldValue = func(context.Context) (*Grid, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GridMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GridMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GridMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GridMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grid.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *GridMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GridMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GridMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GridMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GridMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GridMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetGUID sets the "guid" field.
func (m *GridMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *GridMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *GridMutation) ResetGUID() {
	m.guid = nil
}

// SetAccount sets the "account" field.
func (m *GridMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *GridMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *GridMutation) ResetAccount() {
	m.account = nil
}

// SetToken sets the "token" field.
func (m *GridMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *GridMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *GridMutation) ResetToken() {
	m.token = nil
}

// SetSymbol sets the "symbol" field.
func (m *GridMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *GridMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *GridMutation) ResetSymbol() {
	m.symbol = nil
}

// SetStrategyId sets the "strategyId" field.
func (m *GridMutation) SetStrategyId(s string) {
	m.strategyId = &s
}

// StrategyId returns the value of the "strategyId" field in the mutation.
func (m *GridMutation) StrategyId() (r string, exists bool) {
	v := m.strategyId
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyId returns the old "strategyId" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldStrategyId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyId: %w", err)
	}
	return oldValue.StrategyId, nil
}

// ResetStrategyId resets all changes to the "strategyId" field.
func (m *GridMutation) ResetStrategyId() {
	m.strategyId = nil
}

// SetGridNumber sets the "gridNumber" field.
func (m *GridMutation) SetGridNumber(i int) {
	m.gridNumber = &i
	m.addgridNumber = nil
}

// GridNumber returns the value of the "gridNumber" field in the mutation.
func (m *GridMutation) GridNumber() (r int, exists bool) {
	v := m.gridNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldGridNumber returns the old "gridNumber" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldGridNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridNumber: %w", err)
	}
	return oldValue.GridNumber, nil
}

// AddGridNumber adds i to the "gridNumber" field.
func (m *GridMutation) AddGridNumber(i int) {
	if m.addgridNumber != nil {
		*m.addgridNumber += i
	} else {
		m.addgridNumber = &i
	}
}

// AddedGridNumber returns the value that was added to the "gridNumber" field in this mutation.
func (m *GridMutation) AddedGridNumber() (r int, exists bool) {
	v := m.addgridNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetGridNumber resets all changes to the "gridNumber" field.
func (m *GridMutation) ResetGridNumber() {
	m.gridNumber = nil
	m.addgridNumber = nil
}

// SetOrderPrice sets the "orderPrice" field.
func (m *GridMutation) SetOrderPrice(d decimal.Decimal) {
	m.orderPrice = &d
}

// OrderPrice returns the value of the "orderPrice" field in the mutation.
func (m *GridMutation) OrderPrice() (r decimal.Decimal, exists bool) {
	v := m.orderPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPrice returns the old "orderPrice" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldOrderPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPrice: %w", err)
	}
	return oldValue.OrderPrice, nil
}

// ResetOrderPrice resets all changes to the "orderPrice" field.
func (m *GridMutation) ResetOrderPrice() {
	m.orderPrice = nil
}

// SetFinalPrice sets the "finalPrice" field.
func (m *GridMutation) SetFinalPrice(d decimal.Decimal) {
	m.finalPrice = &d
}

// FinalPrice returns the value of the "finalPrice" field in the mutation.
func (m *GridMutation) FinalPrice() (r decimal.Decimal, exists bool) {
	v := m.finalPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalPrice returns the old "finalPrice" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldFinalPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalPrice: %w", err)
	}
	return oldValue.FinalPrice, nil
}

// ResetFinalPrice resets all changes to the "finalPrice" field.
func (m *GridMutation) ResetFinalPrice() {
	m.finalPrice = nil
}

// SetAmount sets the "amount" field.
func (m *GridMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GridMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *GridMutation) ResetAmount() {
	m.amount = nil
}

// SetQuantity sets the "quantity" field.
func (m *GridMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *GridMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *GridMutation) ResetQuantity() {
	m.quantity = nil
}

// SetStatus sets the "status" field.
func (m *GridMutation) SetStatus(gr grid.Status) {
	m.status = &gr
}

// Status returns the value of the "status" field in the mutation.
func (m *GridMutation) Status() (r grid.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldStatus(ctx context.Context) (v grid.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GridMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the GridMutation builder.
func (m *GridMutation) Where(ps ...predicate.Grid) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GridMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GridMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grid, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GridMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GridMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grid).
func (m *GridMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GridMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, grid.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, grid.FieldUpdateTime)
	}
	if m.guid != nil {
		fields = append(fields, grid.FieldGUID)
	}
	if m.account != nil {
		fields = append(fields, grid.FieldAccount)
	}
	if m.token != nil {
		fields = append(fields, grid.FieldToken)
	}
	if m.symbol != nil {
		fields = append(fields, grid.FieldSymbol)
	}
	if m.strategyId != nil {
		fields = append(fields, grid.FieldStrategyId)
	}
	if m.gridNumber != nil {
		fields = append(fields, grid.FieldGridNumber)
	}
	if m.orderPrice != nil {
		fields = append(fields, grid.FieldOrderPrice)
	}
	if m.finalPrice != nil {
		fields = append(fields, grid.FieldFinalPrice)
	}
	if m.amount != nil {
		fields = append(fields, grid.FieldAmount)
	}
	if m.quantity != nil {
		fields = append(fields, grid.FieldQuantity)
	}
	if m.status != nil {
		fields = append(fields, grid.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GridMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grid.FieldCreateTime:
		return m.CreateTime()
	case grid.FieldUpdateTime:
		return m.UpdateTime()
	case grid.FieldGUID:
		return m.GUID()
	case grid.FieldAccount:
		return m.Account()
	case grid.FieldToken:
		return m.Token()
	case grid.FieldSymbol:
		return m.Symbol()
	case grid.FieldStrategyId:
		return m.StrategyId()
	case grid.FieldGridNumber:
		return m.GridNumber()
	case grid.FieldOrderPrice:
		return m.OrderPrice()
	case grid.FieldFinalPrice:
		return m.FinalPrice()
	case grid.FieldAmount:
		return m.Amount()
	case grid.FieldQuantity:
		return m.Quantity()
	case grid.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GridMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grid.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case grid.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case grid.FieldGUID:
		return m.OldGUID(ctx)
	case grid.FieldAccount:
		return m.OldAccount(ctx)
	case grid.FieldToken:
		return m.OldToken(ctx)
	case grid.FieldSymbol:
		return m.OldSymbol(ctx)
	case grid.FieldStrategyId:
		return m.OldStrategyId(ctx)
	case grid.FieldGridNumber:
		return m.OldGridNumber(ctx)
	case grid.FieldOrderPrice:
		return m.OldOrderPrice(ctx)
	case grid.FieldFinalPrice:
		return m.OldFinalPrice(ctx)
	case grid.FieldAmount:
		return m.OldAmount(ctx)
	case grid.FieldQuantity:
		return m.OldQuantity(ctx)
	case grid.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Grid field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grid.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case grid.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case grid.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case grid.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case grid.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case grid.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case grid.FieldStrategyId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyId(v)
		return nil
	case grid.FieldGridNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridNumber(v)
		return nil
	case grid.FieldOrderPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPrice(v)
		return nil
	case grid.FieldFinalPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalPrice(v)
		return nil
	case grid.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case grid.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case grid.FieldStatus:
		v, ok := value.(grid.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Grid field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GridMutation) AddedFields() []string {
	var fields []string
	if m.addgridNumber != nil {
		fields = append(fields, grid.FieldGridNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GridMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grid.FieldGridNumber:
		return m.AddedGridNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grid.FieldGridNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGridNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Grid numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GridMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GridMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GridMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Grid nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GridMutation) ResetField(name string) error {
	switch name {
	case grid.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case grid.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case grid.FieldGUID:
		m.ResetGUID()
		return nil
	case grid.FieldAccount:
		m.ResetAccount()
		return nil
	case grid.FieldToken:
		m.ResetToken()
		return nil
	case grid.FieldSymbol:
		m.ResetSymbol()
		return nil
	case grid.FieldStrategyId:
		m.ResetStrategyId()
		return nil
	case grid.FieldGridNumber:
		m.ResetGridNumber()
		return nil
	case grid.FieldOrderPrice:
		m.ResetOrderPrice()
		return nil
	case grid.FieldFinalPrice:
		m.ResetFinalPrice()
		return nil
	case grid.FieldAmount:
		m.ResetAmount()
		return nil
	case grid.FieldQuantity:
		m.ResetQuantity()
		return nil
	case grid.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Grid field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GridMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GridMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GridMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GridMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GridMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GridMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GridMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Grid unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GridMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Grid edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	account       *string
	token         *string
	symbol        *string
	gridId        *string
	gridNumber    *int
	addgridNumber *int
	gridBuyCost   *decimal.Decimal
	strategyId    *string
	_type         *order.Type
	price         *decimal.Decimal
	finalPrice    *decimal.Decimal
	inAmount      *decimal.Decimal
	outAmount     *decimal.Decimal
	status        *order.Status
	txHash        *string
	reason        *string
	profit        *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Order, error)
	predicates    []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAccount sets the "account" field.
func (m *OrderMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *OrderMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *OrderMutation) ResetAccount() {
	m.account = nil
}

// SetToken sets the "token" field.
func (m *OrderMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OrderMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *OrderMutation) ResetToken() {
	m.token = nil
}

// SetSymbol sets the "symbol" field.
func (m *OrderMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *OrderMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *OrderMutation) ResetSymbol() {
	m.symbol = nil
}

// SetGridId sets the "gridId" field.
func (m *OrderMutation) SetGridId(s string) {
	m.gridId = &s
}

// GridId returns the value of the "gridId" field in the mutation.
func (m *OrderMutation) GridId() (r string, exists bool) {
	v := m.gridId
	if v == nil {
		return
	}
	return *v, true
}

// OldGridId returns the old "gridId" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGridId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridId: %w", err)
	}
	return oldValue.GridId, nil
}

// ClearGridId clears the value of the "gridId" field.
func (m *OrderMutation) ClearGridId() {
	m.gridId = nil
	m.clearedFields[order.FieldGridId] = struct{}{}
}

// GridIdCleared returns if the "gridId" field was cleared in this mutation.
func (m *OrderMutation) GridIdCleared() bool {
	_, ok := m.clearedFields[order.FieldGridId]
	return ok
}

// ResetGridId resets all changes to the "gridId" field.
func (m *OrderMutation) ResetGridId() {
	m.gridId = nil
	delete(m.clearedFields, order.FieldGridId)
}

// SetGridNumber sets the "gridNumber" field.
func (m *OrderMutation) SetGridNumber(i int) {
	m.gridNumber = &i
	m.addgridNumber = nil
}

// GridNumber returns the value of the "gridNumber" field in the mutation.
func (m *OrderMutation) GridNumber() (r int, exists bool) {
	v := m.gridNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldGridNumber returns the old "gridNumber" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGridNumber(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridNumber: %w", err)
	}
	return oldValue.GridNumber, nil
}

// AddGridNumber adds i to the "gridNumber" field.
func (m *OrderMutation) AddGridNumber(i int) {
	if m.addgridNumber != nil {
		*m.addgridNumber += i
	} else {
		m.addgridNumber = &i
	}
}

// AddedGridNumber returns the value that was added to the "gridNumber" field in this mutation.
func (m *OrderMutation) AddedGridNumber() (r int, exists bool) {
	v := m.addgridNumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearGridNumber clears the value of the "gridNumber" field.
func (m *OrderMutation) ClearGridNumber() {
	m.gridNumber = nil
	m.addgridNumber = nil
	m.clearedFields[order.FieldGridNumber] = struct{}{}
}

// GridNumberCleared returns if the "gridNumber" field was cleared in this mutation.
func (m *OrderMutation) GridNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldGridNumber]
	return ok
}

// ResetGridNumber resets all changes to the "gridNumber" field.
func (m *OrderMutation) ResetGridNumber() {
	m.gridNumber = nil
	m.addgridNumber = nil
	delete(m.clearedFields, order.FieldGridNumber)
}

// SetGridBuyCost sets the "gridBuyCost" field.
func (m *OrderMutation) SetGridBuyCost(d decimal.Decimal) {
	m.gridBuyCost = &d
}

// GridBuyCost returns the value of the "gridBuyCost" field in the mutation.
func (m *OrderMutation) GridBuyCost() (r decimal.Decimal, exists bool) {
	v := m.gridBuyCost
	if v == nil {
		return
	}
	return *v, true
}

// OldGridBuyCost returns the old "gridBuyCost" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGridBuyCost(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridBuyCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridBuyCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridBuyCost: %w", err)
	}
	return oldValue.GridBuyCost, nil
}

// ClearGridBuyCost clears the value of the "gridBuyCost" field.
func (m *OrderMutation) ClearGridBuyCost() {
	m.gridBuyCost = nil
	m.clearedFields[order.FieldGridBuyCost] = struct{}{}
}

// GridBuyCostCleared returns if the "gridBuyCost" field was cleared in this mutation.
func (m *OrderMutation) GridBuyCostCleared() bool {
	_, ok := m.clearedFields[order.FieldGridBuyCost]
	return ok
}

// ResetGridBuyCost resets all changes to the "gridBuyCost" field.
func (m *OrderMutation) ResetGridBuyCost() {
	m.gridBuyCost = nil
	delete(m.clearedFields, order.FieldGridBuyCost)
}

// SetStrategyId sets the "strategyId" field.
func (m *OrderMutation) SetStrategyId(s string) {
	m.strategyId = &s
}

// StrategyId returns the value of the "strategyId" field in the mutation.
func (m *OrderMutation) StrategyId() (r string, exists bool) {
	v := m.strategyId
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyId returns the old "strategyId" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStrategyId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyId: %w", err)
	}
	return oldValue.StrategyId, nil
}

// ResetStrategyId resets all changes to the "strategyId" field.
func (m *OrderMutation) ResetStrategyId() {
	m.strategyId = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(o order.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r order.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v order.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
}

// SetPrice sets the "price" field.
func (m *OrderMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderMutation) ResetPrice() {
	m.price = nil
}

// SetFinalPrice sets the "finalPrice" field.
func (m *OrderMutation) SetFinalPrice(d decimal.Decimal) {
	m.finalPrice = &d
}

// FinalPrice returns the value of the "finalPrice" field in the mutation.
func (m *OrderMutation) FinalPrice() (r decimal.Decimal, exists bool) {
	v := m.finalPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalPrice returns the old "finalPrice" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFinalPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalPrice: %w", err)
	}
	return oldValue.FinalPrice, nil
}

// ResetFinalPrice resets all changes to the "finalPrice" field.
func (m *OrderMutation) ResetFinalPrice() {
	m.finalPrice = nil
}

// SetInAmount sets the "inAmount" field.
func (m *OrderMutation) SetInAmount(d decimal.Decimal) {
	m.inAmount = &d
}

// InAmount returns the value of the "inAmount" field in the mutation.
func (m *OrderMutation) InAmount() (r decimal.Decimal, exists bool) {
	v := m.inAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldInAmount returns the old "inAmount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInAmount: %w", err)
	}
	return oldValue.InAmount, nil
}

// ResetInAmount resets all changes to the "inAmount" field.
func (m *OrderMutation) ResetInAmount() {
	m.inAmount = nil
}

// SetOutAmount sets the "outAmount" field.
func (m *OrderMutation) SetOutAmount(d decimal.Decimal) {
	m.outAmount = &d
}

// OutAmount returns the value of the "outAmount" field in the mutation.
func (m *OrderMutation) OutAmount() (r decimal.Decimal, exists bool) {
	v := m.outAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldOutAmount returns the old "outAmount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOutAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutAmount: %w", err)
	}
	return oldValue.OutAmount, nil
}

// ResetOutAmount resets all changes to the "outAmount" field.
func (m *OrderMutation) ResetOutAmount() {
	m.outAmount = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetTxHash sets the "txHash" field.
func (m *OrderMutation) SetTxHash(s string) {
	m.txHash = &s
}

// TxHash returns the value of the "txHash" field in the mutation.
func (m *OrderMutation) TxHash() (r string, exists bool) {
	v := m.txHash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "txHash" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ResetTxHash resets all changes to the "txHash" field.
func (m *OrderMutation) ResetTxHash() {
	m.txHash = nil
}

// SetReason sets the "reason" field.
func (m *OrderMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *OrderMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *OrderMutation) ResetReason() {
	m.reason = nil
}

// SetProfit sets the "profit" field.
func (m *OrderMutation) SetProfit(d decimal.Decimal) {
	m.profit = &d
}

// Profit returns the value of the "profit" field in the mutation.
func (m *OrderMutation) Profit() (r decimal.Decimal, exists bool) {
	v := m.profit
	if v == nil {
		return
	}
	return *v, true
}

// OldProfit returns the old "profit" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldProfit(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfit: %w", err)
	}
	return oldValue.Profit, nil
}

// ClearProfit clears the value of the "profit" field.
func (m *OrderMutation) ClearProfit() {
	m.profit = nil
	m.clearedFields[order.FieldProfit] = struct{}{}
}

// ProfitCleared returns if the "profit" field was cleared in this mutation.
func (m *OrderMutation) ProfitCleared() bool {
	_, ok := m.clearedFields[order.FieldProfit]
	return ok
}

// ResetProfit resets all changes to the "profit" field.
func (m *OrderMutation) ResetProfit() {
	m.profit = nil
	delete(m.clearedFields, order.FieldProfit)
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.create_time != nil {
		fields = append(fields, order.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, order.FieldUpdateTime)
	}
	if m.account != nil {
		fields = append(fields, order.FieldAccount)
	}
	if m.token != nil {
		fields = append(fields, order.FieldToken)
	}
	if m.symbol != nil {
		fields = append(fields, order.FieldSymbol)
	}
	if m.gridId != nil {
		fields = append(fields, order.FieldGridId)
	}
	if m.gridNumber != nil {
		fields = append(fields, order.FieldGridNumber)
	}
	if m.gridBuyCost != nil {
		fields = append(fields, order.FieldGridBuyCost)
	}
	if m.strategyId != nil {
		fields = append(fields, order.FieldStrategyId)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.price != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.finalPrice != nil {
		fields = append(fields, order.FieldFinalPrice)
	}
	if m.inAmount != nil {
		fields = append(fields, order.FieldInAmount)
	}
	if m.outAmount != nil {
		fields = append(fields, order.FieldOutAmount)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.txHash != nil {
		fields = append(fields, order.FieldTxHash)
	}
	if m.reason != nil {
		fields = append(fields, order.FieldReason)
	}
	if m.profit != nil {
		fields = append(fields, order.FieldProfit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreateTime:
		return m.CreateTime()
	case order.FieldUpdateTime:
		return m.UpdateTime()
	case order.FieldAccount:
		return m.Account()
	case order.FieldToken:
		return m.Token()
	case order.FieldSymbol:
		return m.Symbol()
	case order.FieldGridId:
		return m.GridId()
	case order.FieldGridNumber:
		return m.GridNumber()
	case order.FieldGridBuyCost:
		return m.GridBuyCost()
	case order.FieldStrategyId:
		return m.StrategyId()
	case order.FieldType:
		return m.GetType()
	case order.FieldPrice:
		return m.Price()
	case order.FieldFinalPrice:
		return m.FinalPrice()
	case order.FieldInAmount:
		return m.InAmount()
	case order.FieldOutAmount:
		return m.OutAmount()
	case order.FieldStatus:
		return m.Status()
	case order.FieldTxHash:
		return m.TxHash()
	case order.FieldReason:
		return m.Reason()
	case order.FieldProfit:
		return m.Profit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case order.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case order.FieldAccount:
		return m.OldAccount(ctx)
	case order.FieldToken:
		return m.OldToken(ctx)
	case order.FieldSymbol:
		return m.OldSymbol(ctx)
	case order.FieldGridId:
		return m.OldGridId(ctx)
	case order.FieldGridNumber:
		return m.OldGridNumber(ctx)
	case order.FieldGridBuyCost:
		return m.OldGridBuyCost(ctx)
	case order.FieldStrategyId:
		return m.OldStrategyId(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldPrice:
		return m.OldPrice(ctx)
	case order.FieldFinalPrice:
		return m.OldFinalPrice(ctx)
	case order.FieldInAmount:
		return m.OldInAmount(ctx)
	case order.FieldOutAmount:
		return m.OldOutAmount(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldTxHash:
		return m.OldTxHash(ctx)
	case order.FieldReason:
		return m.OldReason(ctx)
	case order.FieldProfit:
		return m.OldProfit(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case order.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case order.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case order.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case order.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case order.FieldGridId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridId(v)
		return nil
	case order.FieldGridNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridNumber(v)
		return nil
	case order.FieldGridBuyCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridBuyCost(v)
		return nil
	case order.FieldStrategyId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyId(v)
		return nil
	case order.FieldType:
		v, ok := value.(order.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case order.FieldFinalPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalPrice(v)
		return nil
	case order.FieldInAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInAmount(v)
		return nil
	case order.FieldOutAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutAmount(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case order.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case order.FieldProfit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfit(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addgridNumber != nil {
		fields = append(fields, order.FieldGridNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldGridNumber:
		return m.AddedGridNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldGridNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGridNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldGridId) {
		fields = append(fields, order.FieldGridId)
	}
	if m.FieldCleared(order.FieldGridNumber) {
		fields = append(fields, order.FieldGridNumber)
	}
	if m.FieldCleared(order.FieldGridBuyCost) {
		fields = append(fields, order.FieldGridBuyCost)
	}
	if m.FieldCleared(order.FieldProfit) {
		fields = append(fields, order.FieldProfit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldGridId:
		m.ClearGridId()
		return nil
	case order.FieldGridNumber:
		m.ClearGridNumber()
		return nil
	case order.FieldGridBuyCost:
		m.ClearGridBuyCost()
		return nil
	case order.FieldProfit:
		m.ClearProfit()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case order.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case order.FieldAccount:
		m.ResetAccount()
		return nil
	case order.FieldToken:
		m.ResetToken()
		return nil
	case order.FieldSymbol:
		m.ResetSymbol()
		return nil
	case order.FieldGridId:
		m.ResetGridId()
		return nil
	case order.FieldGridNumber:
		m.ResetGridNumber()
		return nil
	case order.FieldGridBuyCost:
		m.ResetGridBuyCost()
		return nil
	case order.FieldStrategyId:
		m.ResetStrategyId()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldPrice:
		m.ResetPrice()
		return nil
	case order.FieldFinalPrice:
		m.ResetFinalPrice()
		return nil
	case order.FieldInAmount:
		m.ResetInAmount()
		return nil
	case order.FieldOutAmount:
		m.ResetOutAmount()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldTxHash:
		m.ResetTxHash()
		return nil
	case order.FieldReason:
		m.ResetReason()
		return nil
	case order.FieldProfit:
		m.ResetProfit()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	userId             *int64
	adduserId          *int64
	maxRetries         *int64
	addmaxRetries      *int64
	slippageBps        *int
	addslippageBps     *int
	sellSlippageBps    *int
	addsellSlippageBps *int
	exitSlippageBps    *int
	addexitSlippageBps *int
	maxLamports        *int64
	addmaxLamports     *int64
	priorityLevel      *settings.PriorityLevel
	dexAggregator      *settings.DexAggregator
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Settings, error)
	predicates         []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SettingsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SettingsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SettingsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SettingsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SettingsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SettingsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserId sets the "userId" field.
func (m *SettingsMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *SettingsMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *SettingsMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *SettingsMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *SettingsMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetMaxRetries sets the "maxRetries" field.
func (m *SettingsMutation) SetMaxRetries(i int64) {
	m.maxRetries = &i
	m.addmaxRetries = nil
}

// MaxRetries returns the value of the "maxRetries" field in the mutation.
func (m *SettingsMutation) MaxRetries() (r int64, exists bool) {
	v := m.maxRetries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "maxRetries" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMaxRetries(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "maxRetries" field.
func (m *SettingsMutation) AddMaxRetries(i int64) {
	if m.addmaxRetries != nil {
		*m.addmaxRetries += i
	} else {
		m.addmaxRetries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "maxRetries" field in this mutation.
func (m *SettingsMutation) AddedMaxRetries() (r int64, exists bool) {
	v := m.addmaxRetries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "maxRetries" field.
func (m *SettingsMutation) ResetMaxRetries() {
	m.maxRetries = nil
	m.addmaxRetries = nil
}

// SetSlippageBps sets the "slippageBps" field.
func (m *SettingsMutation) SetSlippageBps(i int) {
	m.slippageBps = &i
	m.addslippageBps = nil
}

// SlippageBps returns the value of the "slippageBps" field in the mutation.
func (m *SettingsMutation) SlippageBps() (r int, exists bool) {
	v := m.slippageBps
	if v == nil {
		return
	}
	return *v, true
}

// OldSlippageBps returns the old "slippageBps" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSlippageBps(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlippageBps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlippageBps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlippageBps: %w", err)
	}
	return oldValue.SlippageBps, nil
}

// AddSlippageBps adds i to the "slippageBps" field.
func (m *SettingsMutation) AddSlippageBps(i int) {
	if m.addslippageBps != nil {
		*m.addslippageBps += i
	} else {
		m.addslippageBps = &i
	}
}

// AddedSlippageBps returns the value that was added to the "slippageBps" field in this mutation.
func (m *SettingsMutation) AddedSlippageBps() (r int, exists bool) {
	v := m.addslippageBps
	if v == nil {
		return
	}
	return *v, true
}

// ResetSlippageBps resets all changes to the "slippageBps" field.
func (m *SettingsMutation) ResetSlippageBps() {
	m.slippageBps = nil
	m.addslippageBps = nil
}

// SetSellSlippageBps sets the "sellSlippageBps" field.
func (m *SettingsMutation) SetSellSlippageBps(i int) {
	m.sellSlippageBps = &i
	m.addsellSlippageBps = nil
}

// SellSlippageBps returns the value of the "sellSlippageBps" field in the mutation.
func (m *SettingsMutation) SellSlippageBps() (r int, exists bool) {
	v := m.sellSlippageBps
	if v == nil {
		return
	}
	return *v, true
}

// OldSellSlippageBps returns the old "sellSlippageBps" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSellSlippageBps(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellSlippageBps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellSlippageBps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellSlippageBps: %w", err)
	}
	return oldValue.SellSlippageBps, nil
}

// AddSellSlippageBps adds i to the "sellSlippageBps" field.
func (m *SettingsMutation) AddSellSlippageBps(i int) {
	if m.addsellSlippageBps != nil {
		*m.addsellSlippageBps += i
	} else {
		m.addsellSlippageBps = &i
	}
}

// AddedSellSlippageBps returns the value that was added to the "sellSlippageBps" field in this mutation.
func (m *SettingsMutation) AddedSellSlippageBps() (r int, exists bool) {
	v := m.addsellSlippageBps
	if v == nil {
		return
	}
	return *v, true
}

// ClearSellSlippageBps clears the value of the "sellSlippageBps" field.
func (m *SettingsMutation) ClearSellSlippageBps() {
	m.sellSlippageBps = nil
	m.addsellSlippageBps = nil
	m.clearedFields[settings.FieldSellSlippageBps] = struct{}{}
}

// SellSlippageBpsCleared returns if the "sellSlippageBps" field was cleared in this mutation.
func (m *SettingsMutation) SellSlippageBpsCleared() bool {
	_, ok := m.clearedFields[settings.FieldSellSlippageBps]
	return ok
}

// ResetSellSlippageBps resets all changes to the "sellSlippageBps" field.
func (m *SettingsMutation) ResetSellSlippageBps() {
	m.sellSlippageBps = nil
	m.addsellSlippageBps = nil
	delete(m.clearedFields, settings.FieldSellSlippageBps)
}

// SetExitSlippageBps sets the "exitSlippageBps" field.
func (m *SettingsMutation) SetExitSlippageBps(i int) {
	m.exitSlippageBps = &i
	m.addexitSlippageBps = nil
}

// ExitSlippageBps returns the value of the "exitSlippageBps" field in the mutation.
func (m *SettingsMutation) ExitSlippageBps() (r int, exists bool) {
	v := m.exitSlippageBps
	if v == nil {
		return
	}
	return *v, true
}

// OldExitSlippageBps returns the old "exitSlippageBps" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldExitSlippageBps(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitSlippageBps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitSlippageBps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitSlippageBps: %w", err)
	}
	return oldValue.ExitSlippageBps, nil
}

// AddExitSlippageBps adds i to the "exitSlippageBps" field.
func (m *SettingsMutation) AddExitSlippageBps(i int) {
	if m.addexitSlippageBps != nil {
		*m.addexitSlippageBps += i
	} else {
		m.addexitSlippageBps = &i
	}
}

// AddedExitSlippageBps returns the value that was added to the "exitSlippageBps" field in this mutation.
func (m *SettingsMutation) AddedExitSlippageBps() (r int, exists bool) {
	v := m.addexitSlippageBps
	if v == nil {
		return
	}
	return *v, true
}

// ClearExitSlippageBps clears the value of the "exitSlippageBps" field.
func (m *SettingsMutation) ClearExitSlippageBps() {
	m.exitSlippageBps = nil
	m.addexitSlippageBps = nil
	m.clearedFields[settings.FieldExitSlippageBps] = struct{}{}
}

// ExitSlippageBpsCleared returns if the "exitSlippageBps" field was cleared in this mutation.
func (m *SettingsMutation) ExitSlippageBpsCleared() bool {
	_, ok := m.clearedFields[settings.FieldExitSlippageBps]
	return ok
}

// ResetExitSlippageBps resets all changes to the "exitSlippageBps" field.
func (m *SettingsMutation) ResetExitSlippageBps() {
	m.exitSlippageBps = nil
	m.addexitSlippageBps = nil
	delete(m.clearedFields, settings.FieldExitSlippageBps)
}

// SetMaxLamports sets the "maxLamports" field.
func (m *SettingsMutation) SetMaxLamports(i int64) {
	m.maxLamports = &i
	m.addmaxLamports = nil
}

// MaxLamports returns the value of the "maxLamports" field in the mutation.
func (m *SettingsMutation) MaxLamports() (r int64, exists bool) {
	v := m.maxLamports
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLamports returns the old "maxLamports" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMaxLamports(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLamports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLamports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLamports: %w", err)
	}
	return oldValue.MaxLamports, nil
}

// AddMaxLamports adds i to the "maxLamports" field.
func (m *SettingsMutation) AddMaxLamports(i int64) {
	if m.addmaxLamports != nil {
		*m.addmaxLamports += i
	} else {
		m.addmaxLamports = &i
	}
}

// AddedMaxLamports returns the value that was added to the "maxLamports" field in this mutation.
func (m *SettingsMutation) AddedMaxLamports() (r int64, exists bool) {
	v := m.addmaxLamports
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLamports resets all changes to the "maxLamports" field.
func (m *SettingsMutation) ResetMaxLamports() {
	m.maxLamports = nil
	m.addmaxLamports = nil
}

// SetPriorityLevel sets the "priorityLevel" field.
func (m *SettingsMutation) SetPriorityLevel(sl settings.PriorityLevel) {
	m.priorityLevel = &sl
}

// PriorityLevel returns the value of the "priorityLevel" field in the mutation.
func (m *SettingsMutation) PriorityLevel() (r settings.PriorityLevel, exists bool) {
	v := m.priorityLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldPriorityLevel returns the old "priorityLevel" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldPriorityLevel(ctx context.Context) (v settings.PriorityLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriorityLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriorityLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriorityLevel: %w", err)
	}
	return oldValue.PriorityLevel, nil
}

// ResetPriorityLevel resets all changes to the "priorityLevel" field.
func (m *SettingsMutation) ResetPriorityLevel() {
	m.priorityLevel = nil
}

// SetDexAggregator sets the "dexAggregator" field.
func (m *SettingsMutation) SetDexAggregator(sa settings.DexAggregator) {
	m.dexAggregator = &sa
}

// DexAggregator returns the value of the "dexAggregator" field in the mutation.
func (m *SettingsMutation) DexAggregator() (r settings.DexAggregator, exists bool) {
	v := m.dexAggregator
	if v == nil {
		return
	}
	return *v, true
}

// OldDexAggregator returns the old "dexAggregator" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDexAggregator(ctx context.Context) (v settings.DexAggregator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDexAggregator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDexAggregator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDexAggregator: %w", err)
	}
	return oldValue.DexAggregator, nil
}

// ResetDexAggregator resets all changes to the "dexAggregator" field.
func (m *SettingsMutation) ResetDexAggregator() {
	m.dexAggregator = nil
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, settings.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, settings.FieldUpdateTime)
	}
	if m.userId != nil {
		fields = append(fields, settings.FieldUserId)
	}
	if m.maxRetries != nil {
		fields = append(fields, settings.FieldMaxRetries)
	}
	if m.slippageBps != nil {
		fields = append(fields, settings.FieldSlippageBps)
	}
	if m.sellSlippageBps != nil {
		fields = append(fields, settings.FieldSellSlippageBps)
	}
	if m.exitSlippageBps != nil {
		fields = append(fields, settings.FieldExitSlippageBps)
	}
	if m.maxLamports != nil {
		fields = append(fields, settings.FieldMaxLamports)
	}
	if m.priorityLevel != nil {
		fields = append(fields, settings.FieldPriorityLevel)
	}
	if m.dexAggregator != nil {
		fields = append(fields, settings.FieldDexAggregator)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCreateTime:
		return m.CreateTime()
	case settings.FieldUpdateTime:
		return m.UpdateTime()
	case settings.FieldUserId:
		return m.UserId()
	case settings.FieldMaxRetries:
		return m.MaxRetries()
	case settings.FieldSlippageBps:
		return m.SlippageBps()
	case settings.FieldSellSlippageBps:
		return m.SellSlippageBps()
	case settings.FieldExitSlippageBps:
		return m.ExitSlippageBps()
	case settings.FieldMaxLamports:
		return m.MaxLamports()
	case settings.FieldPriorityLevel:
		return m.PriorityLevel()
	case settings.FieldDexAggregator:
		return m.DexAggregator()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case settings.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case settings.FieldUserId:
		return m.OldUserId(ctx)
	case settings.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case settings.FieldSlippageBps:
		return m.OldSlippageBps(ctx)
	case settings.FieldSellSlippageBps:
		return m.OldSellSlippageBps(ctx)
	case settings.FieldExitSlippageBps:
		return m.OldExitSlippageBps(ctx)
	case settings.FieldMaxLamports:
		return m.OldMaxLamports(ctx)
	case settings.FieldPriorityLevel:
		return m.OldPriorityLevel(ctx)
	case settings.FieldDexAggregator:
		return m.OldDexAggregator(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case settings.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case settings.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case settings.FieldMaxRetries:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case settings.FieldSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlippageBps(v)
		return nil
	case settings.FieldSellSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellSlippageBps(v)
		return nil
	case settings.FieldExitSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitSlippageBps(v)
		return nil
	case settings.FieldMaxLamports:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLamports(v)
		return nil
	case settings.FieldPriorityLevel:
		v, ok := value.(settings.PriorityLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriorityLevel(v)
		return nil
	case settings.FieldDexAggregator:
		v, ok := value.(settings.DexAggregator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDexAggregator(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, settings.FieldUserId)
	}
	if m.addmaxRetries != nil {
		fields = append(fields, settings.FieldMaxRetries)
	}
	if m.addslippageBps != nil {
		fields = append(fields, settings.FieldSlippageBps)
	}
	if m.addsellSlippageBps != nil {
		fields = append(fields, settings.FieldSellSlippageBps)
	}
	if m.addexitSlippageBps != nil {
		fields = append(fields, settings.FieldExitSlippageBps)
	}
	if m.addmaxLamports != nil {
		fields = append(fields, settings.FieldMaxLamports)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldUserId:
		return m.AddedUserId()
	case settings.FieldMaxRetries:
		return m.AddedMaxRetries()
	case settings.FieldSlippageBps:
		return m.AddedSlippageBps()
	case settings.FieldSellSlippageBps:
		return m.AddedSellSlippageBps()
	case settings.FieldExitSlippageBps:
		return m.AddedExitSlippageBps()
	case settings.FieldMaxLamports:
		return m.AddedMaxLamports()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case settings.FieldMaxRetries:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	case settings.FieldSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSlippageBps(v)
		return nil
	case settings.FieldSellSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellSlippageBps(v)
		return nil
	case settings.FieldExitSlippageBps:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExitSlippageBps(v)
		return nil
	case settings.FieldMaxLamports:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLamports(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldSellSlippageBps) {
		fields = append(fields, settings.FieldSellSlippageBps)
	}
	if m.FieldCleared(settings.FieldExitSlippageBps) {
		fields = append(fields, settings.FieldExitSlippageBps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldSellSlippageBps:
		m.ClearSellSlippageBps()
		return nil
	case settings.FieldExitSlippageBps:
		m.ClearExitSlippageBps()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case settings.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case settings.FieldUserId:
		m.ResetUserId()
		return nil
	case settings.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case settings.FieldSlippageBps:
		m.ResetSlippageBps()
		return nil
	case settings.FieldSellSlippageBps:
		m.ResetSellSlippageBps()
		return nil
	case settings.FieldExitSlippageBps:
		m.ResetExitSlippageBps()
		return nil
	case settings.FieldMaxLamports:
		m.ResetMaxLamports()
		return nil
	case settings.FieldPriorityLevel:
		m.ResetPriorityLevel()
		return nil
	case settings.FieldDexAggregator:
		m.ResetDexAggregator()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	guid                        *string
	userId                      *int64
	adduserId                   *int64
	token                       *string
	symbol                      *string
	martinFactor                *float64
	addmartinFactor             *float64
	maxGridLimit                *int
	addmaxGridLimit             *int
	takeProfitRatio             *decimal.Decimal
	upperPriceBound             *decimal.Decimal
	lowerPriceBound             *decimal.Decimal
	initialOrderSize            *decimal.Decimal
	lastKlineVolume             *decimal.Decimal
	fiveKlineVolume             *decimal.Decimal
	firstOrderId                *int
	addfirstOrderId             *int
	upperBoundExit              *decimal.Decimal
	stopLossExit                *decimal.Decimal
	takeProfitExit              *decimal.Decimal
	globalTakeProfitRatio       *decimal.Decimal
	dynamicStopLoss             *bool
	dropOn                      *bool
	candlesToCheck              *int
	addcandlesToCheck           *int
	dropThreshold               *decimal.Decimal
	enableAutoBuy               *bool
	enableAutoSell              *bool
	enableAutoExit              *bool
	enablePushNotification      *bool
	status                      *strategy.Status
	gridTrend                   *string
	lastLowerThresholdAlertTime *time.Time
	lastUpperThresholdAlertTime *time.Time
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Strategy, error)
	predicates                  []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id int) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StrategyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StrategyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StrategyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StrategyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StrategyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StrategyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetGUID sets the "guid" field.
func (m *StrategyMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *StrategyMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *StrategyMutation) ResetGUID() {
	m.guid = nil
}

// SetUserId sets the "userId" field.
func (m *StrategyMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *StrategyMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *StrategyMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *StrategyMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *StrategyMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetToken sets the "token" field.
func (m *StrategyMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *StrategyMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *StrategyMutation) ResetToken() {
	m.token = nil
}

// SetSymbol sets the "symbol" field.
func (m *StrategyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *StrategyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *StrategyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetMartinFactor sets the "martinFactor" field.
func (m *StrategyMutation) SetMartinFactor(f float64) {
	m.martinFactor = &f
	m.addmartinFactor = nil
}

// MartinFactor returns the value of the "martinFactor" field in the mutation.
func (m *StrategyMutation) MartinFactor() (r float64, exists bool) {
	v := m.martinFactor
	if v == nil {
		return
	}
	return *v, true
}

// OldMartinFactor returns the old "martinFactor" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMartinFactor(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMartinFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMartinFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMartinFactor: %w", err)
	}
	return oldValue.MartinFactor, nil
}

// AddMartinFactor adds f to the "martinFactor" field.
func (m *StrategyMutation) AddMartinFactor(f float64) {
	if m.addmartinFactor != nil {
		*m.addmartinFactor += f
	} else {
		m.addmartinFactor = &f
	}
}

// AddedMartinFactor returns the value that was added to the "martinFactor" field in this mutation.
func (m *StrategyMutation) AddedMartinFactor() (r float64, exists bool) {
	v := m.addmartinFactor
	if v == nil {
		return
	}
	return *v, true
}

// ResetMartinFactor resets all changes to the "martinFactor" field.
func (m *StrategyMutation) ResetMartinFactor() {
	m.martinFactor = nil
	m.addmartinFactor = nil
}

// SetMaxGridLimit sets the "maxGridLimit" field.
func (m *StrategyMutation) SetMaxGridLimit(i int) {
	m.maxGridLimit = &i
	m.addmaxGridLimit = nil
}

// MaxGridLimit returns the value of the "maxGridLimit" field in the mutation.
func (m *StrategyMutation) MaxGridLimit() (r int, exists bool) {
	v := m.maxGridLimit
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxGridLimit returns the old "maxGridLimit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMaxGridLimit(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxGridLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxGridLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxGridLimit: %w", err)
	}
	return oldValue.MaxGridLimit, nil
}

// AddMaxGridLimit adds i to the "maxGridLimit" field.
func (m *StrategyMutation) AddMaxGridLimit(i int) {
	if m.addmaxGridLimit != nil {
		*m.addmaxGridLimit += i
	} else {
		m.addmaxGridLimit = &i
	}
}

// AddedMaxGridLimit returns the value that was added to the "maxGridLimit" field in this mutation.
func (m *StrategyMutation) AddedMaxGridLimit() (r int, exists bool) {
	v := m.addmaxGridLimit
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxGridLimit clears the value of the "maxGridLimit" field.
func (m *StrategyMutation) ClearMaxGridLimit() {
	m.maxGridLimit = nil
	m.addmaxGridLimit = nil
	m.clearedFields[strategy.FieldMaxGridLimit] = struct{}{}
}

// MaxGridLimitCleared returns if the "maxGridLimit" field was cleared in this mutation.
func (m *StrategyMutation) MaxGridLimitCleared() bool {
	_, ok := m.clearedFields[strategy.FieldMaxGridLimit]
	return ok
}

// ResetMaxGridLimit resets all changes to the "maxGridLimit" field.
func (m *StrategyMutation) ResetMaxGridLimit() {
	m.maxGridLimit = nil
	m.addmaxGridLimit = nil
	delete(m.clearedFields, strategy.FieldMaxGridLimit)
}

// SetTakeProfitRatio sets the "takeProfitRatio" field.
func (m *StrategyMutation) SetTakeProfitRatio(d decimal.Decimal) {
	m.takeProfitRatio = &d
}

// TakeProfitRatio returns the value of the "takeProfitRatio" field in the mutation.
func (m *StrategyMutation) TakeProfitRatio() (r decimal.Decimal, exists bool) {
	v := m.takeProfitRatio
	if v == nil {
		return
	}
	return *v, true
}

// OldTakeProfitRatio returns the old "takeProfitRatio" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldTakeProfitRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakeProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakeProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakeProfitRatio: %w", err)
	}
	return oldValue.TakeProfitRatio, nil
}

// ResetTakeProfitRatio resets all changes to the "takeProfitRatio" field.
func (m *StrategyMutation) ResetTakeProfitRatio() {
	m.takeProfitRatio = nil
}

// SetUpperPriceBound sets the "upperPriceBound" field.
func (m *StrategyMutation) SetUpperPriceBound(d decimal.Decimal) {
	m.upperPriceBound = &d
}

// UpperPriceBound returns the value of the "upperPriceBound" field in the mutation.
func (m *StrategyMutation) UpperPriceBound() (r decimal.Decimal, exists bool) {
	v := m.upperPriceBound
	if v == nil {
		return
	}
	return *v, true
}

// OldUpperPriceBound returns the old "upperPriceBound" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpperPriceBound(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpperPriceBound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpperPriceBound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpperPriceBound: %w", err)
	}
	return oldValue.UpperPriceBound, nil
}

// ResetUpperPriceBound resets all changes to the "upperPriceBound" field.
func (m *StrategyMutation) ResetUpperPriceBound() {
	m.upperPriceBound = nil
}

// SetLowerPriceBound sets the "lowerPriceBound" field.
func (m *StrategyMutation) SetLowerPriceBound(d decimal.Decimal) {
	m.lowerPriceBound = &d
}

// LowerPriceBound returns the value of the "lowerPriceBound" field in the mutation.
func (m *StrategyMutation) LowerPriceBound() (r decimal.Decimal, exists bool) {
	v := m.lowerPriceBound
	if v == nil {
		return
	}
	return *v, true
}

// OldLowerPriceBound returns the old "lowerPriceBound" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLowerPriceBound(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowerPriceBound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowerPriceBound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowerPriceBound: %w", err)
	}
	return oldValue.LowerPriceBound, nil
}

// ResetLowerPriceBound resets all changes to the "lowerPriceBound" field.
func (m *StrategyMutation) ResetLowerPriceBound() {
	m.lowerPriceBound = nil
}

// SetInitialOrderSize sets the "initialOrderSize" field.
func (m *StrategyMutation) SetInitialOrderSize(d decimal.Decimal) {
	m.initialOrderSize = &d
}

// InitialOrderSize returns the value of the "initialOrderSize" field in the mutation.
func (m *StrategyMutation) InitialOrderSize() (r decimal.Decimal, exists bool) {
	v := m.initialOrderSize
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialOrderSize returns the old "initialOrderSize" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldInitialOrderSize(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialOrderSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialOrderSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialOrderSize: %w", err)
	}
	return oldValue.InitialOrderSize, nil
}

// ResetInitialOrderSize resets all changes to the "initialOrderSize" field.
func (m *StrategyMutation) ResetInitialOrderSize() {
	m.initialOrderSize = nil
}

// SetLastKlineVolume sets the "lastKlineVolume" field.
func (m *StrategyMutation) SetLastKlineVolume(d decimal.Decimal) {
	m.lastKlineVolume = &d
}

// LastKlineVolume returns the value of the "lastKlineVolume" field in the mutation.
func (m *StrategyMutation) LastKlineVolume() (r decimal.Decimal, exists bool) {
	v := m.lastKlineVolume
	if v == nil {
		return
	}
	return *v, true
}

// OldLastKlineVolume returns the old "lastKlineVolume" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastKlineVolume(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastKlineVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastKlineVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastKlineVolume: %w", err)
	}
	return oldValue.LastKlineVolume, nil
}

// ClearLastKlineVolume clears the value of the "lastKlineVolume" field.
func (m *StrategyMutation) ClearLastKlineVolume() {
	m.lastKlineVolume = nil
	m.clearedFields[strategy.FieldLastKlineVolume] = struct{}{}
}

// LastKlineVolumeCleared returns if the "lastKlineVolume" field was cleared in this mutation.
func (m *StrategyMutation) LastKlineVolumeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldLastKlineVolume]
	return ok
}

// ResetLastKlineVolume resets all changes to the "lastKlineVolume" field.
func (m *StrategyMutation) ResetLastKlineVolume() {
	m.lastKlineVolume = nil
	delete(m.clearedFields, strategy.FieldLastKlineVolume)
}

// SetFiveKlineVolume sets the "fiveKlineVolume" field.
func (m *StrategyMutation) SetFiveKlineVolume(d decimal.Decimal) {
	m.fiveKlineVolume = &d
}

// FiveKlineVolume returns the value of the "fiveKlineVolume" field in the mutation.
func (m *StrategyMutation) FiveKlineVolume() (r decimal.Decimal, exists bool) {
	v := m.fiveKlineVolume
	if v == nil {
		return
	}
	return *v, true
}

// OldFiveKlineVolume returns the old "fiveKlineVolume" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldFiveKlineVolume(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiveKlineVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiveKlineVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiveKlineVolume: %w", err)
	}
	return oldValue.FiveKlineVolume, nil
}

// ClearFiveKlineVolume clears the value of the "fiveKlineVolume" field.
func (m *StrategyMutation) ClearFiveKlineVolume() {
	m.fiveKlineVolume = nil
	m.clearedFields[strategy.FieldFiveKlineVolume] = struct{}{}
}

// FiveKlineVolumeCleared returns if the "fiveKlineVolume" field was cleared in this mutation.
func (m *StrategyMutation) FiveKlineVolumeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldFiveKlineVolume]
	return ok
}

// ResetFiveKlineVolume resets all changes to the "fiveKlineVolume" field.
func (m *StrategyMutation) ResetFiveKlineVolume() {
	m.fiveKlineVolume = nil
	delete(m.clearedFields, strategy.FieldFiveKlineVolume)
}

// SetFirstOrderId sets the "firstOrderId" field.
func (m *StrategyMutation) SetFirstOrderId(i int) {
	m.firstOrderId = &i
	m.addfirstOrderId = nil
}

// FirstOrderId returns the value of the "firstOrderId" field in the mutation.
func (m *StrategyMutation) FirstOrderId() (r int, exists bool) {
	v := m.firstOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstOrderId returns the old "firstOrderId" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldFirstOrderId(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstOrderId: %w", err)
	}
	return oldValue.FirstOrderId, nil
}

// AddFirstOrderId adds i to the "firstOrderId" field.
func (m *StrategyMutation) AddFirstOrderId(i int) {
	if m.addfirstOrderId != nil {
		*m.addfirstOrderId += i
	} else {
		m.addfirstOrderId = &i
	}
}

// AddedFirstOrderId returns the value that was added to the "firstOrderId" field in this mutation.
func (m *StrategyMutation) AddedFirstOrderId() (r int, exists bool) {
	v := m.addfirstOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstOrderId clears the value of the "firstOrderId" field.
func (m *StrategyMutation) ClearFirstOrderId() {
	m.firstOrderId = nil
	m.addfirstOrderId = nil
	m.clearedFields[strategy.FieldFirstOrderId] = struct{}{}
}

// FirstOrderIdCleared returns if the "firstOrderId" field was cleared in this mutation.
func (m *StrategyMutation) FirstOrderIdCleared() bool {
	_, ok := m.clearedFields[strategy.FieldFirstOrderId]
	return ok
}

// ResetFirstOrderId resets all changes to the "firstOrderId" field.
func (m *StrategyMutation) ResetFirstOrderId() {
	m.firstOrderId = nil
	m.addfirstOrderId = nil
	delete(m.clearedFields, strategy.FieldFirstOrderId)
}

// SetUpperBoundExit sets the "upperBoundExit" field.
func (m *StrategyMutation) SetUpperBoundExit(d decimal.Decimal) {
	m.upperBoundExit = &d
}

// UpperBoundExit returns the value of the "upperBoundExit" field in the mutation.
func (m *StrategyMutation) UpperBoundExit() (r decimal.Decimal, exists bool) {
	v := m.upperBoundExit
	if v == nil {
		return
	}
	return *v, true
}

// OldUpperBoundExit returns the old "upperBoundExit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpperBoundExit(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpperBoundExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpperBoundExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpperBoundExit: %w", err)
	}
	return oldValue.UpperBoundExit, nil
}

// ClearUpperBoundExit clears the value of the "upperBoundExit" field.
func (m *StrategyMutation) ClearUpperBoundExit() {
	m.upperBoundExit = nil
	m.clearedFields[strategy.FieldUpperBoundExit] = struct{}{}
}

// UpperBoundExitCleared returns if the "upperBoundExit" field was cleared in this mutation.
func (m *StrategyMutation) UpperBoundExitCleared() bool {
	_, ok := m.clearedFields[strategy.FieldUpperBoundExit]
	return ok
}

// ResetUpperBoundExit resets all changes to the "upperBoundExit" field.
func (m *StrategyMutation) ResetUpperBoundExit() {
	m.upperBoundExit = nil
	delete(m.clearedFields, strategy.FieldUpperBoundExit)
}

// SetStopLossExit sets the "stopLossExit" field.
func (m *StrategyMutation) SetStopLossExit(d decimal.Decimal) {
	m.stopLossExit = &d
}

// StopLossExit returns the value of the "stopLossExit" field in the mutation.
func (m *StrategyMutation) StopLossExit() (r decimal.Decimal, exists bool) {
	v := m.stopLossExit
	if v == nil {
		return
	}
	return *v, true
}

// OldStopLossExit returns the old "stopLossExit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStopLossExit(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopLossExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopLossExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopLossExit: %w", err)
	}
	return oldValue.StopLossExit, nil
}

// ClearStopLossExit clears the value of the "stopLossExit" field.
func (m *StrategyMutation) ClearStopLossExit() {
	m.stopLossExit = nil
	m.clearedFields[strategy.FieldStopLossExit] = struct{}{}
}

// StopLossExitCleared returns if the "stopLossExit" field was cleared in this mutation.
func (m *StrategyMutation) StopLossExitCleared() bool {
	_, ok := m.clearedFields[strategy.FieldStopLossExit]
	return ok
}

// ResetStopLossExit resets all changes to the "stopLossExit" field.
func (m *StrategyMutation) ResetStopLossExit() {
	m.stopLossExit = nil
	delete(m.clearedFields, strategy.FieldStopLossExit)
}

// SetTakeProfitExit sets the "takeProfitExit" field.
func (m *StrategyMutation) SetTakeProfitExit(d decimal.Decimal) {
	m.takeProfitExit = &d
}

// TakeProfitExit returns the value of the "takeProfitExit" field in the mutation.
func (m *StrategyMutation) TakeProfitExit() (r decimal.Decimal, exists bool) {
	v := m.takeProfitExit
	if v == nil {
		return
	}
	return *v, true
}

// OldTakeProfitExit returns the old "takeProfitExit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldTakeProfitExit(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakeProfitExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakeProfitExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakeProfitExit: %w", err)
	}
	return oldValue.TakeProfitExit, nil
}

// ClearTakeProfitExit clears the value of the "takeProfitExit" field.
func (m *StrategyMutation) ClearTakeProfitExit() {
	m.takeProfitExit = nil
	m.clearedFields[strategy.FieldTakeProfitExit] = struct{}{}
}

// TakeProfitExitCleared returns if the "takeProfitExit" field was cleared in this mutation.
func (m *StrategyMutation) TakeProfitExitCleared() bool {
	_, ok := m.clearedFields[strategy.FieldTakeProfitExit]
	return ok
}

// ResetTakeProfitExit resets all changes to the "takeProfitExit" field.
func (m *StrategyMutation) ResetTakeProfitExit() {
	m.takeProfitExit = nil
	delete(m.clearedFields, strategy.FieldTakeProfitExit)
}

// SetGlobalTakeProfitRatio sets the "globalTakeProfitRatio" field.
func (m *StrategyMutation) SetGlobalTakeProfitRatio(d decimal.Decimal) {
	m.globalTakeProfitRatio = &d
}

// GlobalTakeProfitRatio returns the value of the "globalTakeProfitRatio" field in the mutation.
func (m *StrategyMutation) GlobalTakeProfitRatio() (r decimal.Decimal, exists bool) {
	v := m.globalTakeProfitRatio
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalTakeProfitRatio returns the old "globalTakeProfitRatio" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldGlobalTakeProfitRatio(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalTakeProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalTakeProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalTakeProfitRatio: %w", err)
	}
	return oldValue.GlobalTakeProfitRatio, nil
}

// ClearGlobalTakeProfitRatio clears the value of the "globalTakeProfitRatio" field.
func (m *StrategyMutation) ClearGlobalTakeProfitRatio() {
	m.globalTakeProfitRatio = nil
	m.clearedFields[strategy.FieldGlobalTakeProfitRatio] = struct{}{}
}

// GlobalTakeProfitRatioCleared returns if the "globalTakeProfitRatio" field was cleared in this mutation.
func (m *StrategyMutation) GlobalTakeProfitRatioCleared() bool {
	_, ok := m.clearedFields[strategy.FieldGlobalTakeProfitRatio]
	return ok
}

// ResetGlobalTakeProfitRatio resets all changes to the "globalTakeProfitRatio" field.
func (m *StrategyMutation) ResetGlobalTakeProfitRatio() {
	m.globalTakeProfitRatio = nil
	delete(m.clearedFields, strategy.FieldGlobalTakeProfitRatio)
}

// SetDynamicStopLoss sets the "dynamicStopLoss" field.
func (m *StrategyMutation) SetDynamicStopLoss(b bool) {
	m.dynamicStopLoss = &b
}

// DynamicStopLoss returns the value of the "dynamicStopLoss" field in the mutation.
func (m *StrategyMutation) DynamicStopLoss() (r bool, exists bool) {
	v := m.dynamicStopLoss
	if v == nil {
		return
	}
	return *v, true
}

// OldDynamicStopLoss returns the old "dynamicStopLoss" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDynamicStopLoss(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDynamicStopLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDynamicStopLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDynamicStopLoss: %w", err)
	}
	return oldValue.DynamicStopLoss, nil
}

// ClearDynamicStopLoss clears the value of the "dynamicStopLoss" field.
func (m *StrategyMutation) ClearDynamicStopLoss() {
	m.dynamicStopLoss = nil
	m.clearedFields[strategy.FieldDynamicStopLoss] = struct{}{}
}

// DynamicStopLossCleared returns if the "dynamicStopLoss" field was cleared in this mutation.
func (m *StrategyMutation) DynamicStopLossCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDynamicStopLoss]
	return ok
}

// ResetDynamicStopLoss resets all changes to the "dynamicStopLoss" field.
func (m *StrategyMutation) ResetDynamicStopLoss() {
	m.dynamicStopLoss = nil
	delete(m.clearedFields, strategy.FieldDynamicStopLoss)
}

// SetDropOn sets the "dropOn" field.
func (m *StrategyMutation) SetDropOn(b bool) {
	m.dropOn = &b
}

// DropOn returns the value of the "dropOn" field in the mutation.
func (m *StrategyMutation) DropOn() (r bool, exists bool) {
	v := m.dropOn
	if v == nil {
		return
	}
	return *v, true
}

// OldDropOn returns the old "dropOn" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDropOn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDropOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDropOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDropOn: %w", err)
	}
	return oldValue.DropOn, nil
}

// ClearDropOn clears the value of the "dropOn" field.
func (m *StrategyMutation) ClearDropOn() {
	m.dropOn = nil
	m.clearedFields[strategy.FieldDropOn] = struct{}{}
}

// DropOnCleared returns if the "dropOn" field was cleared in this mutation.
func (m *StrategyMutation) DropOnCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDropOn]
	return ok
}

// ResetDropOn resets all changes to the "dropOn" field.
func (m *StrategyMutation) ResetDropOn() {
	m.dropOn = nil
	delete(m.clearedFields, strategy.FieldDropOn)
}

// SetCandlesToCheck sets the "candlesToCheck" field.
func (m *StrategyMutation) SetCandlesToCheck(i int) {
	m.candlesToCheck = &i
	m.addcandlesToCheck = nil
}

// CandlesToCheck returns the value of the "candlesToCheck" field in the mutation.
func (m *StrategyMutation) CandlesToCheck() (r int, exists bool) {
	v := m.candlesToCheck
	if v == nil {
		return
	}
	return *v, true
}

// OldCandlesToCheck returns the old "candlesToCheck" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCandlesToCheck(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandlesToCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandlesToCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandlesToCheck: %w", err)
	}
	return oldValue.CandlesToCheck, nil
}

// AddCandlesToCheck adds i to the "candlesToCheck" field.
func (m *StrategyMutation) AddCandlesToCheck(i int) {
	if m.addcandlesToCheck != nil {
		*m.addcandlesToCheck += i
	} else {
		m.addcandlesToCheck = &i
	}
}

// AddedCandlesToCheck returns the value that was added to the "candlesToCheck" field in this mutation.
func (m *StrategyMutation) AddedCandlesToCheck() (r int, exists bool) {
	v := m.addcandlesToCheck
	if v == nil {
		return
	}
	return *v, true
}

// ClearCandlesToCheck clears the value of the "candlesToCheck" field.
func (m *StrategyMutation) ClearCandlesToCheck() {
	m.candlesToCheck = nil
	m.addcandlesToCheck = nil
	m.clearedFields[strategy.FieldCandlesToCheck] = struct{}{}
}

// CandlesToCheckCleared returns if the "candlesToCheck" field was cleared in this mutation.
func (m *StrategyMutation) CandlesToCheckCleared() bool {
	_, ok := m.clearedFields[strategy.FieldCandlesToCheck]
	return ok
}

// ResetCandlesToCheck resets all changes to the "candlesToCheck" field.
func (m *StrategyMutation) ResetCandlesToCheck() {
	m.candlesToCheck = nil
	m.addcandlesToCheck = nil
	delete(m.clearedFields, strategy.FieldCandlesToCheck)
}

// SetDropThreshold sets the "dropThreshold" field.
func (m *StrategyMutation) SetDropThreshold(d decimal.Decimal) {
	m.dropThreshold = &d
}

// DropThreshold returns the value of the "dropThreshold" field in the mutation.
func (m *StrategyMutation) DropThreshold() (r decimal.Decimal, exists bool) {
	v := m.dropThreshold
	if v == nil {
		return
	}
	return *v, true
}

// OldDropThreshold returns the old "dropThreshold" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDropThreshold(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDropThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDropThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDropThreshold: %w", err)
	}
	return oldValue.DropThreshold, nil
}

// ClearDropThreshold clears the value of the "dropThreshold" field.
func (m *StrategyMutation) ClearDropThreshold() {
	m.dropThreshold = nil
	m.clearedFields[strategy.FieldDropThreshold] = struct{}{}
}

// DropThresholdCleared returns if the "dropThreshold" field was cleared in this mutation.
func (m *StrategyMutation) DropThresholdCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDropThreshold]
	return ok
}

// ResetDropThreshold resets all changes to the "dropThreshold" field.
func (m *StrategyMutation) ResetDropThreshold() {
	m.dropThreshold = nil
	delete(m.clearedFields, strategy.FieldDropThreshold)
}

// SetEnableAutoBuy sets the "enableAutoBuy" field.
func (m *StrategyMutation) SetEnableAutoBuy(b bool) {
	m.enableAutoBuy = &b
}

// EnableAutoBuy returns the value of the "enableAutoBuy" field in the mutation.
func (m *StrategyMutation) EnableAutoBuy() (r bool, exists bool) {
	v := m.enableAutoBuy
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoBuy returns the old "enableAutoBuy" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnableAutoBuy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoBuy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoBuy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoBuy: %w", err)
	}
	return oldValue.EnableAutoBuy, nil
}

// ResetEnableAutoBuy resets all changes to the "enableAutoBuy" field.
func (m *StrategyMutation) ResetEnableAutoBuy() {
	m.enableAutoBuy = nil
}

// SetEnableAutoSell sets the "enableAutoSell" field.
func (m *StrategyMutation) SetEnableAutoSell(b bool) {
	m.enableAutoSell = &b
}

// EnableAutoSell returns the value of the "enableAutoSell" field in the mutation.
func (m *StrategyMutation) EnableAutoSell() (r bool, exists bool) {
	v := m.enableAutoSell
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoSell returns the old "enableAutoSell" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnableAutoSell(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoSell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoSell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoSell: %w", err)
	}
	return oldValue.EnableAutoSell, nil
}

// ResetEnableAutoSell resets all changes to the "enableAutoSell" field.
func (m *StrategyMutation) ResetEnableAutoSell() {
	m.enableAutoSell = nil
}

// SetEnableAutoExit sets the "enableAutoExit" field.
func (m *StrategyMutation) SetEnableAutoExit(b bool) {
	m.enableAutoExit = &b
}

// EnableAutoExit returns the value of the "enableAutoExit" field in the mutation.
func (m *StrategyMutation) EnableAutoExit() (r bool, exists bool) {
	v := m.enableAutoExit
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoExit returns the old "enableAutoExit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnableAutoExit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoExit: %w", err)
	}
	return oldValue.EnableAutoExit, nil
}

// ResetEnableAutoExit resets all changes to the "enableAutoExit" field.
func (m *StrategyMutation) ResetEnableAutoExit() {
	m.enableAutoExit = nil
}

// SetEnablePushNotification sets the "enablePushNotification" field.
func (m *StrategyMutation) SetEnablePushNotification(b bool) {
	m.enablePushNotification = &b
}

// EnablePushNotification returns the value of the "enablePushNotification" field in the mutation.
func (m *StrategyMutation) EnablePushNotification() (r bool, exists bool) {
	v := m.enablePushNotification
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePushNotification returns the old "enablePushNotification" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnablePushNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePushNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePushNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePushNotification: %w", err)
	}
	return oldValue.EnablePushNotification, nil
}

// ResetEnablePushNotification resets all changes to the "enablePushNotification" field.
func (m *StrategyMutation) ResetEnablePushNotification() {
	m.enablePushNotification = nil
}

// SetStatus sets the "status" field.
func (m *StrategyMutation) SetStatus(s strategy.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StrategyMutation) Status() (r strategy.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStatus(ctx context.Context) (v strategy.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StrategyMutation) ResetStatus() {
	m.status = nil
}

// SetGridTrend sets the "gridTrend" field.
func (m *StrategyMutation) SetGridTrend(s string) {
	m.gridTrend = &s
}

// GridTrend returns the value of the "gridTrend" field in the mutation.
func (m *StrategyMutation) GridTrend() (r string, exists bool) {
	v := m.gridTrend
	if v == nil {
		return
	}
	return *v, true
}

// OldGridTrend returns the old "gridTrend" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldGridTrend(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridTrend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridTrend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridTrend: %w", err)
	}
	return oldValue.GridTrend, nil
}

// ClearGridTrend clears the value of the "gridTrend" field.
func (m *StrategyMutation) ClearGridTrend() {
	m.gridTrend = nil
	m.clearedFields[strategy.FieldGridTrend] = struct{}{}
}

// GridTrendCleared returns if the "gridTrend" field was cleared in this mutation.
func (m *StrategyMutation) GridTrendCleared() bool {
	_, ok := m.clearedFields[strategy.FieldGridTrend]
	return ok
}

// ResetGridTrend resets all changes to the "gridTrend" field.
func (m *StrategyMutation) ResetGridTrend() {
	m.gridTrend = nil
	delete(m.clearedFields, strategy.FieldGridTrend)
}

// SetLastLowerThresholdAlertTime sets the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) SetLastLowerThresholdAlertTime(t time.Time) {
	m.lastLowerThresholdAlertTime = &t
}

// LastLowerThresholdAlertTime returns the value of the "lastLowerThresholdAlertTime" field in the mutation.
func (m *StrategyMutation) LastLowerThresholdAlertTime() (r time.Time, exists bool) {
	v := m.lastLowerThresholdAlertTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLowerThresholdAlertTime returns the old "lastLowerThresholdAlertTime" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastLowerThresholdAlertTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLowerThresholdAlertTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLowerThresholdAlertTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLowerThresholdAlertTime: %w", err)
	}
	return oldValue.LastLowerThresholdAlertTime, nil
}

// ClearLastLowerThresholdAlertTime clears the value of the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) ClearLastLowerThresholdAlertTime() {
	m.lastLowerThresholdAlertTime = nil
	m.clearedFields[strategy.FieldLastLowerThresholdAlertTime] = struct{}{}
}

// LastLowerThresholdAlertTimeCleared returns if the "lastLowerThresholdAlertTime" field was cleared in this mutation.
func (m *StrategyMutation) LastLowerThresholdAlertTimeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldLastLowerThresholdAlertTime]
	return ok
}

// ResetLastLowerThresholdAlertTime resets all changes to the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) ResetLastLowerThresholdAlertTime() {
	m.lastLowerThresholdAlertTime = nil
	delete(m.clearedFields, strategy.FieldLastLowerThresholdAlertTime)
}

// SetLastUpperThresholdAlertTime sets the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) SetLastUpperThresholdAlertTime(t time.Time) {
	m.lastUpperThresholdAlertTime = &t
}

// LastUpperThresholdAlertTime returns the value of the "lastUpperThresholdAlertTime" field in the mutation.
func (m *StrategyMutation) LastUpperThresholdAlertTime() (r time.Time, exists bool) {
	v := m.lastUpperThresholdAlertTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpperThresholdAlertTime returns the old "lastUpperThresholdAlertTime" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastUpperThresholdAlertTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpperThresholdAlertTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpperThresholdAlertTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpperThresholdAlertTime: %w", err)
	}
	return oldValue.LastUpperThresholdAlertTime, nil
}

// ClearLastUpperThresholdAlertTime clears the value of the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) ClearLastUpperThresholdAlertTime() {
	m.lastUpperThresholdAlertTime = nil
	m.clearedFields[strategy.FieldLastUpperThresholdAlertTime] = struct{}{}
}

// LastUpperThresholdAlertTimeCleared returns if the "lastUpperThresholdAlertTime" field was cleared in this mutation.
func (m *StrategyMutation) LastUpperThresholdAlertTimeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldLastUpperThresholdAlertTime]
	return ok
}

// ResetLastUpperThresholdAlertTime resets all changes to the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) ResetLastUpperThresholdAlertTime() {
	m.lastUpperThresholdAlertTime = nil
	delete(m.clearedFields, strategy.FieldLastUpperThresholdAlertTime)
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.create_time != nil {
		fields = append(fields, strategy.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, strategy.FieldUpdateTime)
	}
	if m.guid != nil {
		fields = append(fields, strategy.FieldGUID)
	}
	if m.userId != nil {
		fields = append(fields, strategy.FieldUserId)
	}
	if m.token != nil {
		fields = append(fields, strategy.FieldToken)
	}
	if m.symbol != nil {
		fields = append(fields, strategy.FieldSymbol)
	}
	if m.martinFactor != nil {
		fields = append(fields, strategy.FieldMartinFactor)
	}
	if m.maxGridLimit != nil {
		fields = append(fields, strategy.FieldMaxGridLimit)
	}
	if m.takeProfitRatio != nil {
		fields = append(fields, strategy.FieldTakeProfitRatio)
	}
	if m.upperPriceBound != nil {
		fields = append(fields, strategy.FieldUpperPriceBound)
	}
	if m.lowerPriceBound != nil {
		fields = append(fields, strategy.FieldLowerPriceBound)
	}
	if m.initialOrderSize != nil {
		fields = append(fields, strategy.FieldInitialOrderSize)
	}
	if m.lastKlineVolume != nil {
		fields = append(fields, strategy.FieldLastKlineVolume)
	}
	if m.fiveKlineVolume != nil {
		fields = append(fields, strategy.FieldFiveKlineVolume)
	}
	if m.firstOrderId != nil {
		fields = append(fields, strategy.FieldFirstOrderId)
	}
	if m.upperBoundExit != nil {
		fields = append(fields, strategy.FieldUpperBoundExit)
	}
	if m.stopLossExit != nil {
		fields = append(fields, strategy.FieldStopLossExit)
	}
	if m.takeProfitExit != nil {
		fields = append(fields, strategy.FieldTakeProfitExit)
	}
	if m.globalTakeProfitRatio != nil {
		fields = append(fields, strategy.FieldGlobalTakeProfitRatio)
	}
	if m.dynamicStopLoss != nil {
		fields = append(fields, strategy.FieldDynamicStopLoss)
	}
	if m.dropOn != nil {
		fields = append(fields, strategy.FieldDropOn)
	}
	if m.candlesToCheck != nil {
		fields = append(fields, strategy.FieldCandlesToCheck)
	}
	if m.dropThreshold != nil {
		fields = append(fields, strategy.FieldDropThreshold)
	}
	if m.enableAutoBuy != nil {
		fields = append(fields, strategy.FieldEnableAutoBuy)
	}
	if m.enableAutoSell != nil {
		fields = append(fields, strategy.FieldEnableAutoSell)
	}
	if m.enableAutoExit != nil {
		fields = append(fields, strategy.FieldEnableAutoExit)
	}
	if m.enablePushNotification != nil {
		fields = append(fields, strategy.FieldEnablePushNotification)
	}
	if m.status != nil {
		fields = append(fields, strategy.FieldStatus)
	}
	if m.gridTrend != nil {
		fields = append(fields, strategy.FieldGridTrend)
	}
	if m.lastLowerThresholdAlertTime != nil {
		fields = append(fields, strategy.FieldLastLowerThresholdAlertTime)
	}
	if m.lastUpperThresholdAlertTime != nil {
		fields = append(fields, strategy.FieldLastUpperThresholdAlertTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldCreateTime:
		return m.CreateTime()
	case strategy.FieldUpdateTime:
		return m.UpdateTime()
	case strategy.FieldGUID:
		return m.GUID()
	case strategy.FieldUserId:
		return m.UserId()
	case strategy.FieldToken:
		return m.Token()
	case strategy.FieldSymbol:
		return m.Symbol()
	case strategy.FieldMartinFactor:
		return m.MartinFactor()
	case strategy.FieldMaxGridLimit:
		return m.MaxGridLimit()
	case strategy.FieldTakeProfitRatio:
		return m.TakeProfitRatio()
	case strategy.FieldUpperPriceBound:
		return m.UpperPriceBound()
	case strategy.FieldLowerPriceBound:
		return m.LowerPriceBound()
	case strategy.FieldInitialOrderSize:
		return m.InitialOrderSize()
	case strategy.FieldLastKlineVolume:
		return m.LastKlineVolume()
	case strategy.FieldFiveKlineVolume:
		return m.FiveKlineVolume()
	case strategy.FieldFirstOrderId:
		return m.FirstOrderId()
	case strategy.FieldUpperBoundExit:
		return m.UpperBoundExit()
	case strategy.FieldStopLossExit:
		return m.StopLossExit()
	case strategy.FieldTakeProfitExit:
		return m.TakeProfitExit()
	case strategy.FieldGlobalTakeProfitRatio:
		return m.GlobalTakeProfitRatio()
	case strategy.FieldDynamicStopLoss:
		return m.DynamicStopLoss()
	case strategy.FieldDropOn:
		return m.DropOn()
	case strategy.FieldCandlesToCheck:
		return m.CandlesToCheck()
	case strategy.FieldDropThreshold:
		return m.DropThreshold()
	case strategy.FieldEnableAutoBuy:
		return m.EnableAutoBuy()
	case strategy.FieldEnableAutoSell:
		return m.EnableAutoSell()
	case strategy.FieldEnableAutoExit:
		return m.EnableAutoExit()
	case strategy.FieldEnablePushNotification:
		return m.EnablePushNotification()
	case strategy.FieldStatus:
		return m.Status()
	case strategy.FieldGridTrend:
		return m.GridTrend()
	case strategy.FieldLastLowerThresholdAlertTime:
		return m.LastLowerThresholdAlertTime()
	case strategy.FieldLastUpperThresholdAlertTime:
		return m.LastUpperThresholdAlertTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case strategy.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case strategy.FieldGUID:
		return m.OldGUID(ctx)
	case strategy.FieldUserId:
		return m.OldUserId(ctx)
	case strategy.FieldToken:
		return m.OldToken(ctx)
	case strategy.FieldSymbol:
		return m.OldSymbol(ctx)
	case strategy.FieldMartinFactor:
		return m.OldMartinFactor(ctx)
	case strategy.FieldMaxGridLimit:
		return m.OldMaxGridLimit(ctx)
	case strategy.FieldTakeProfitRatio:
		return m.OldTakeProfitRatio(ctx)
	case strategy.FieldUpperPriceBound:
		return m.OldUpperPriceBound(ctx)
	case strategy.FieldLowerPriceBound:
		return m.OldLowerPriceBound(ctx)
	case strategy.FieldInitialOrderSize:
		return m.OldInitialOrderSize(ctx)
	case strategy.FieldLastKlineVolume:
		return m.OldLastKlineVolume(ctx)
	case strategy.FieldFiveKlineVolume:
		return m.OldFiveKlineVolume(ctx)
	case strategy.FieldFirstOrderId:
		return m.OldFirstOrderId(ctx)
	case strategy.FieldUpperBoundExit:
		return m.OldUpperBoundExit(ctx)
	case strategy.FieldStopLossExit:
		return m.OldStopLossExit(ctx)
	case strategy.FieldTakeProfitExit:
		return m.OldTakeProfitExit(ctx)
	case strategy.FieldGlobalTakeProfitRatio:
		return m.OldGlobalTakeProfitRatio(ctx)
	case strategy.FieldDynamicStopLoss:
		return m.OldDynamicStopLoss(ctx)
	case strategy.FieldDropOn:
		return m.OldDropOn(ctx)
	case strategy.FieldCandlesToCheck:
		return m.OldCandlesToCheck(ctx)
	case strategy.FieldDropThreshold:
		return m.OldDropThreshold(ctx)
	case strategy.FieldEnableAutoBuy:
		return m.OldEnableAutoBuy(ctx)
	case strategy.FieldEnableAutoSell:
		return m.OldEnableAutoSell(ctx)
	case strategy.FieldEnableAutoExit:
		return m.OldEnableAutoExit(ctx)
	case strategy.FieldEnablePushNotification:
		return m.OldEnablePushNotification(ctx)
	case strategy.FieldStatus:
		return m.OldStatus(ctx)
	case strategy.FieldGridTrend:
		return m.OldGridTrend(ctx)
	case strategy.FieldLastLowerThresholdAlertTime:
		return m.OldLastLowerThresholdAlertTime(ctx)
	case strategy.FieldLastUpperThresholdAlertTime:
		return m.OldLastUpperThresholdAlertTime(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case strategy.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case strategy.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case strategy.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case strategy.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case strategy.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case strategy.FieldMartinFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMartinFactor(v)
		return nil
	case strategy.FieldMaxGridLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxGridLimit(v)
		return nil
	case strategy.FieldTakeProfitRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakeProfitRatio(v)
		return nil
	case strategy.FieldUpperPriceBound:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpperPriceBound(v)
		return nil
	case strategy.FieldLowerPriceBound:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowerPriceBound(v)
		return nil
	case strategy.FieldInitialOrderSize:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialOrderSize(v)
		return nil
	case strategy.FieldLastKlineVolume:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastKlineVolume(v)
		return nil
	case strategy.FieldFiveKlineVolume:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiveKlineVolume(v)
		return nil
	case strategy.FieldFirstOrderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstOrderId(v)
		return nil
	case strategy.FieldUpperBoundExit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpperBoundExit(v)
		return nil
	case strategy.FieldStopLossExit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopLossExit(v)
		return nil
	case strategy.FieldTakeProfitExit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakeProfitExit(v)
		return nil
	case strategy.FieldGlobalTakeProfitRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalTakeProfitRatio(v)
		return nil
	case strategy.FieldDynamicStopLoss:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDynamicStopLoss(v)
		return nil
	case strategy.FieldDropOn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDropOn(v)
		return nil
	case strategy.FieldCandlesToCheck:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandlesToCheck(v)
		return nil
	case strategy.FieldDropThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDropThreshold(v)
		return nil
	case strategy.FieldEnableAutoBuy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoBuy(v)
		return nil
	case strategy.FieldEnableAutoSell:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoSell(v)
		return nil
	case strategy.FieldEnableAutoExit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoExit(v)
		return nil
	case strategy.FieldEnablePushNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePushNotification(v)
		return nil
	case strategy.FieldStatus:
		v, ok := value.(strategy.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case strategy.FieldGridTrend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridTrend(v)
		return nil
	case strategy.FieldLastLowerThresholdAlertTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLowerThresholdAlertTime(v)
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpperThresholdAlertTime(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, strategy.FieldUserId)
	}
	if m.addmartinFactor != nil {
		fields = append(fields, strategy.FieldMartinFactor)
	}
	if m.addmaxGridLimit != nil {
		fields = append(fields, strategy.FieldMaxGridLimit)
	}
	if m.addfirstOrderId != nil {
		fields = append(fields, strategy.FieldFirstOrderId)
	}
	if m.addcandlesToCheck != nil {
		fields = append(fields, strategy.FieldCandlesToCheck)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldUserId:
		return m.AddedUserId()
	case strategy.FieldMartinFactor:
		return m.AddedMartinFactor()
	case strategy.FieldMaxGridLimit:
		return m.AddedMaxGridLimit()
	case strategy.FieldFirstOrderId:
		return m.AddedFirstOrderId()
	case strategy.FieldCandlesToCheck:
		return m.AddedCandlesToCheck()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case strategy.FieldMartinFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMartinFactor(v)
		return nil
	case strategy.FieldMaxGridLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxGridLimit(v)
		return nil
	case strategy.FieldFirstOrderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstOrderId(v)
		return nil
	case strategy.FieldCandlesToCheck:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCandlesToCheck(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldMaxGridLimit) {
		fields = append(fields, strategy.FieldMaxGridLimit)
	}
	if m.FieldCleared(strategy.FieldLastKlineVolume) {
		fields = append(fields, strategy.FieldLastKlineVolume)
	}
	if m.FieldCleared(strategy.FieldFiveKlineVolume) {
		fields = append(fields, strategy.FieldFiveKlineVolume)
	}
	if m.FieldCleared(strategy.FieldFirstOrderId) {
		fields = append(fields, strategy.FieldFirstOrderId)
	}
	if m.FieldCleared(strategy.FieldUpperBoundExit) {
		fields = append(fields, strategy.FieldUpperBoundExit)
	}
	if m.FieldCleared(strategy.FieldStopLossExit) {
		fields = append(fields, strategy.FieldStopLossExit)
	}
	if m.FieldCleared(strategy.FieldTakeProfitExit) {
		fields = append(fields, strategy.FieldTakeProfitExit)
	}
	if m.FieldCleared(strategy.FieldGlobalTakeProfitRatio) {
		fields = append(fields, strategy.FieldGlobalTakeProfitRatio)
	}
	if m.FieldCleared(strategy.FieldDynamicStopLoss) {
		fields = append(fields, strategy.FieldDynamicStopLoss)
	}
	if m.FieldCleared(strategy.FieldDropOn) {
		fields = append(fields, strategy.FieldDropOn)
	}
	if m.FieldCleared(strategy.FieldCandlesToCheck) {
		fields = append(fields, strategy.FieldCandlesToCheck)
	}
	if m.FieldCleared(strategy.FieldDropThreshold) {
		fields = append(fields, strategy.FieldDropThreshold)
	}
	if m.FieldCleared(strategy.FieldGridTrend) {
		fields = append(fields, strategy.FieldGridTrend)
	}
	if m.FieldCleared(strategy.FieldLastLowerThresholdAlertTime) {
		fields = append(fields, strategy.FieldLastLowerThresholdAlertTime)
	}
	if m.FieldCleared(strategy.FieldLastUpperThresholdAlertTime) {
		fields = append(fields, strategy.FieldLastUpperThresholdAlertTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldMaxGridLimit:
		m.ClearMaxGridLimit()
		return nil
	case strategy.FieldLastKlineVolume:
		m.ClearLastKlineVolume()
		return nil
	case strategy.FieldFiveKlineVolume:
		m.ClearFiveKlineVolume()
		return nil
	case strategy.FieldFirstOrderId:
		m.ClearFirstOrderId()
		return nil
	case strategy.FieldUpperBoundExit:
		m.ClearUpperBoundExit()
		return nil
	case strategy.FieldStopLossExit:
		m.ClearStopLossExit()
		return nil
	case strategy.FieldTakeProfitExit:
		m.ClearTakeProfitExit()
		return nil
	case strategy.FieldGlobalTakeProfitRatio:
		m.ClearGlobalTakeProfitRatio()
		return nil
	case strategy.FieldDynamicStopLoss:
		m.ClearDynamicStopLoss()
		return nil
	case strategy.FieldDropOn:
		m.ClearDropOn()
		return nil
	case strategy.FieldCandlesToCheck:
		m.ClearCandlesToCheck()
		return nil
	case strategy.FieldDropThreshold:
		m.ClearDropThreshold()
		return nil
	case strategy.FieldGridTrend:
		m.ClearGridTrend()
		return nil
	case strategy.FieldLastLowerThresholdAlertTime:
		m.ClearLastLowerThresholdAlertTime()
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		m.ClearLastUpperThresholdAlertTime()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case strategy.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case strategy.FieldGUID:
		m.ResetGUID()
		return nil
	case strategy.FieldUserId:
		m.ResetUserId()
		return nil
	case strategy.FieldToken:
		m.ResetToken()
		return nil
	case strategy.FieldSymbol:
		m.ResetSymbol()
		return nil
	case strategy.FieldMartinFactor:
		m.ResetMartinFactor()
		return nil
	case strategy.FieldMaxGridLimit:
		m.ResetMaxGridLimit()
		return nil
	case strategy.FieldTakeProfitRatio:
		m.ResetTakeProfitRatio()
		return nil
	case strategy.FieldUpperPriceBound:
		m.ResetUpperPriceBound()
		return nil
	case strategy.FieldLowerPriceBound:
		m.ResetLowerPriceBound()
		return nil
	case strategy.FieldInitialOrderSize:
		m.ResetInitialOrderSize()
		return nil
	case strategy.FieldLastKlineVolume:
		m.ResetLastKlineVolume()
		return nil
	case strategy.FieldFiveKlineVolume:
		m.ResetFiveKlineVolume()
		return nil
	case strategy.FieldFirstOrderId:
		m.ResetFirstOrderId()
		return nil
	case strategy.FieldUpperBoundExit:
		m.ResetUpperBoundExit()
		return nil
	case strategy.FieldStopLossExit:
		m.ResetStopLossExit()
		return nil
	case strategy.FieldTakeProfitExit:
		m.ResetTakeProfitExit()
		return nil
	case strategy.FieldGlobalTakeProfitRatio:
		m.ResetGlobalTakeProfitRatio()
		return nil
	case strategy.FieldDynamicStopLoss:
		m.ResetDynamicStopLoss()
		return nil
	case strategy.FieldDropOn:
		m.ResetDropOn()
		return nil
	case strategy.FieldCandlesToCheck:
		m.ResetCandlesToCheck()
		return nil
	case strategy.FieldDropThreshold:
		m.ResetDropThreshold()
		return nil
	case strategy.FieldEnableAutoBuy:
		m.ResetEnableAutoBuy()
		return nil
	case strategy.FieldEnableAutoSell:
		m.ResetEnableAutoSell()
		return nil
	case strategy.FieldEnableAutoExit:
		m.ResetEnableAutoExit()
		return nil
	case strategy.FieldEnablePushNotification:
		m.ResetEnablePushNotification()
		return nil
	case strategy.FieldStatus:
		m.ResetStatus()
		return nil
	case strategy.FieldGridTrend:
		m.ResetGridTrend()
		return nil
	case strategy.FieldLastLowerThresholdAlertTime:
		m.ResetLastLowerThresholdAlertTime()
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		m.ResetLastUpperThresholdAlertTime()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	userId        *int64
	adduserId     *int64
	account       *string
	password      *string
	privateKey    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Wallet, error)
	predicates    []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id int) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WalletMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WalletMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WalletMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WalletMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WalletMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WalletMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserId sets the "userId" field.
func (m *WalletMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *WalletMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *WalletMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *WalletMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *WalletMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetAccount sets the "account" field.
func (m *WalletMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *WalletMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *WalletMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *WalletMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *WalletMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *WalletMutation) ResetPassword() {
	m.password = nil
}

// SetPrivateKey sets the "privateKey" field.
func (m *WalletMutation) SetPrivateKey(s string) {
	m.privateKey = &s
}

// PrivateKey returns the value of the "privateKey" field in the mutation.
func (m *WalletMutation) PrivateKey() (r string, exists bool) {
	v := m.privateKey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "privateKey" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "privateKey" field.
func (m *WalletMutation) ResetPrivateKey() {
	m.privateKey = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wallet.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wallet.FieldUpdateTime)
	}
	if m.userId != nil {
		fields = append(fields, wallet.FieldUserId)
	}
	if m.account != nil {
		fields = append(fields, wallet.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, wallet.FieldPassword)
	}
	if m.privateKey != nil {
		fields = append(fields, wallet.FieldPrivateKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreateTime:
		return m.CreateTime()
	case wallet.FieldUpdateTime:
		return m.UpdateTime()
	case wallet.FieldUserId:
		return m.UserId()
	case wallet.FieldAccount:
		return m.Account()
	case wallet.FieldPassword:
		return m.Password()
	case wallet.FieldPrivateKey:
		return m.PrivateKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wallet.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wallet.FieldUserId:
		return m.OldUserId(ctx)
	case wallet.FieldAccount:
		return m.OldAccount(ctx)
	case wallet.FieldPassword:
		return m.OldPassword(ctx)
	case wallet.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wallet.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wallet.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case wallet.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case wallet.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case wallet.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, wallet.FieldUserId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldUserId:
		return m.AddedUserId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wallet.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wallet.FieldUserId:
		m.ResetUserId()
		return nil
	case wallet.FieldAccount:
		m.ResetAccount()
		return nil
	case wallet.FieldPassword:
		m.ResetPassword()
		return nil
	case wallet.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Wallet edge %s", name)
}
