// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/fachebot/sol-grid-bot/internal/ent/strategy"
	"github.com/shopspring/decimal"
)

// Strategy is the model entity for the Strategy schema.
type Strategy struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// GUID holds the value of the "guid" field.
	GUID string `json:"guid,omitempty"`
	// UserId holds the value of the "userId" field.
	UserId int64 `json:"userId,omitempty"`
	// Token holds the value of the "token" field.
	Token string `json:"token,omitempty"`
	// Symbol holds the value of the "symbol" field.
	Symbol string `json:"symbol,omitempty"`
	// MartinFactor holds the value of the "martinFactor" field.
	MartinFactor float64 `json:"martinFactor,omitempty"`
	// MaxGridLimit holds the value of the "maxGridLimit" field.
	MaxGridLimit *int `json:"maxGridLimit,omitempty"`
	// TakeProfitRatio holds the value of the "takeProfitRatio" field.
	TakeProfitRatio decimal.Decimal `json:"takeProfitRatio,omitempty"`
	// UpperPriceBound holds the value of the "upperPriceBound" field.
	UpperPriceBound decimal.Decimal `json:"upperPriceBound,omitempty"`
	// LowerPriceBound holds the value of the "lowerPriceBound" field.
	LowerPriceBound decimal.Decimal `json:"lowerPriceBound,omitempty"`
	// InitialOrderSize holds the value of the "initialOrderSize" field.
	InitialOrderSize decimal.Decimal `json:"initialOrderSize,omitempty"`
	// LastKlineVolume holds the value of the "lastKlineVolume" field.
	LastKlineVolume *decimal.Decimal `json:"lastKlineVolume,omitempty"`
	// FiveKlineVolume holds the value of the "fiveKlineVolume" field.
	FiveKlineVolume *decimal.Decimal `json:"fiveKlineVolume,omitempty"`
	// FirstOrderId holds the value of the "firstOrderId" field.
	FirstOrderId *int `json:"firstOrderId,omitempty"`
	// UpperBoundExit holds the value of the "upperBoundExit" field.
	UpperBoundExit *decimal.Decimal `json:"upperBoundExit,omitempty"`
	// StopLossExit holds the value of the "stopLossExit" field.
	StopLossExit *decimal.Decimal `json:"stopLossExit,omitempty"`
	// TakeProfitExit holds the value of the "takeProfitExit" field.
	TakeProfitExit *decimal.Decimal `json:"takeProfitExit,omitempty"`
	// GlobalTakeProfitRatio holds the value of the "globalTakeProfitRatio" field.
	GlobalTakeProfitRatio *decimal.Decimal `json:"globalTakeProfitRatio,omitempty"`
	// DynamicStopLoss holds the value of the "dynamicStopLoss" field.
	DynamicStopLoss bool `json:"dynamicStopLoss,omitempty"`
	// DropOn holds the value of the "dropOn" field.
	DropOn bool `json:"dropOn,omitempty"`
	// CandlesToCheck holds the value of the "candlesToCheck" field.
	CandlesToCheck int `json:"candlesToCheck,omitempty"`
	// DropThreshold holds the value of the "dropThreshold" field.
	DropThreshold *decimal.Decimal `json:"dropThreshold,omitempty"`
	// EnableAutoBuy holds the value of the "enableAutoBuy" field.
	EnableAutoBuy bool `json:"enableAutoBuy,omitempty"`
	// EnableAutoSell holds the value of the "enableAutoSell" field.
	EnableAutoSell bool `json:"enableAutoSell,omitempty"`
	// EnableAutoExit holds the value of the "enableAutoExit" field.
	EnableAutoExit bool `json:"enableAutoExit,omitempty"`
	// EnablePushNotification holds the value of the "enablePushNotification" field.
	EnablePushNotification bool `json:"enablePushNotification,omitempty"`
	// Status holds the value of the "status" field.
	Status strategy.Status `json:"status,omitempty"`
	// GridTrend holds the value of the "gridTrend" field.
	GridTrend *string `json:"gridTrend,omitempty"`
	// LastLowerThresholdAlertTime holds the value of the "lastLowerThresholdAlertTime" field.
	LastLowerThresholdAlertTime *time.Time `json:"lastLowerThresholdAlertTime,omitempty"`
	// LastUpperThresholdAlertTime holds the value of the "lastUpperThresholdAlertTime" field.
	LastUpperThresholdAlertTime *time.Time `json:"lastUpperThresholdAlertTime,omitempty"`
	selectValues                sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Strategy) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case strategy.FieldLastKlineVolume, strategy.FieldFiveKlineVolume, strategy.FieldUpperBoundExit, strategy.FieldStopLossExit, strategy.FieldTakeProfitExit, strategy.FieldGlobalTakeProfitRatio, strategy.FieldDropThreshold:
			values[i] = &sql.NullScanner{S: new(decimal.Decimal)}
		case strategy.FieldTakeProfitRatio, strategy.FieldUpperPriceBound, strategy.FieldLowerPriceBound, strategy.FieldInitialOrderSize:
			values[i] = new(decimal.Decimal)
		case strategy.FieldDynamicStopLoss, strategy.FieldDropOn, strategy.FieldEnableAutoBuy, strategy.FieldEnableAutoSell, strategy.FieldEnableAutoExit, strategy.FieldEnablePushNotification:
			values[i] = new(sql.NullBool)
		case strategy.FieldMartinFactor:
			values[i] = new(sql.NullFloat64)
		case strategy.FieldID, strategy.FieldUserId, strategy.FieldMaxGridLimit, strategy.FieldFirstOrderId, strategy.FieldCandlesToCheck:
			values[i] = new(sql.NullInt64)
		case strategy.FieldGUID, strategy.FieldToken, strategy.FieldSymbol, strategy.FieldStatus, strategy.FieldGridTrend:
			values[i] = new(sql.NullString)
		case strategy.FieldCreateTime, strategy.FieldUpdateTime, strategy.FieldLastLowerThresholdAlertTime, strategy.FieldLastUpperThresholdAlertTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Strategy fields.
func (s *Strategy) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case strategy.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			s.ID = int(value.Int64)
		case strategy.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				s.CreateTime = value.Time
			}
		case strategy.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				s.UpdateTime = value.Time
			}
		case strategy.FieldGUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field guid", values[i])
			} else if value.Valid {
				s.GUID = value.String
			}
		case strategy.FieldUserId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field userId", values[i])
			} else if value.Valid {
				s.UserId = value.Int64
			}
		case strategy.FieldToken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field token", values[i])
			} else if value.Valid {
				s.Token = value.String
			}
		case strategy.FieldSymbol:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field symbol", values[i])
			} else if value.Valid {
				s.Symbol = value.String
			}
		case strategy.FieldMartinFactor:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field martinFactor", values[i])
			} else if value.Valid {
				s.MartinFactor = value.Float64
			}
		case strategy.FieldMaxGridLimit:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field maxGridLimit", values[i])
			} else if value.Valid {
				s.MaxGridLimit = new(int)
				*s.MaxGridLimit = int(value.Int64)
			}
		case strategy.FieldTakeProfitRatio:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field takeProfitRatio", values[i])
			} else if value != nil {
				s.TakeProfitRatio = *value
			}
		case strategy.FieldUpperPriceBound:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field upperPriceBound", values[i])
			} else if value != nil {
				s.UpperPriceBound = *value
			}
		case strategy.FieldLowerPriceBound:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field lowerPriceBound", values[i])
			} else if value != nil {
				s.LowerPriceBound = *value
			}
		case strategy.FieldInitialOrderSize:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field initialOrderSize", values[i])
			} else if value != nil {
				s.InitialOrderSize = *value
			}
		case strategy.FieldLastKlineVolume:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field lastKlineVolume", values[i])
			} else if value.Valid {
				s.LastKlineVolume = new(decimal.Decimal)
				*s.LastKlineVolume = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldFiveKlineVolume:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field fiveKlineVolume", values[i])
			} else if value.Valid {
				s.FiveKlineVolume = new(decimal.Decimal)
				*s.FiveKlineVolume = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldFirstOrderId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field firstOrderId", values[i])
			} else if value.Valid {
				s.FirstOrderId = new(int)
				*s.FirstOrderId = int(value.Int64)
			}
		case strategy.FieldUpperBoundExit:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field upperBoundExit", values[i])
			} else if value.Valid {
				s.UpperBoundExit = new(decimal.Decimal)
				*s.UpperBoundExit = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldStopLossExit:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field stopLossExit", values[i])
			} else if value.Valid {
				s.StopLossExit = new(decimal.Decimal)
				*s.StopLossExit = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldTakeProfitExit:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field takeProfitExit", values[i])
			} else if value.Valid {
				s.TakeProfitExit = new(decimal.Decimal)
				*s.TakeProfitExit = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldGlobalTakeProfitRatio:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field globalTakeProfitRatio", values[i])
			} else if value.Valid {
				s.GlobalTakeProfitRatio = new(decimal.Decimal)
				*s.GlobalTakeProfitRatio = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldDynamicStopLoss:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field dynamicStopLoss", values[i])
			} else if value.Valid {
				s.DynamicStopLoss = value.Bool
			}
		case strategy.FieldDropOn:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field dropOn", values[i])
			} else if value.Valid {
				s.DropOn = value.Bool
			}
		case strategy.FieldCandlesToCheck:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field candlesToCheck", values[i])
			} else if value.Valid {
				s.CandlesToCheck = int(value.Int64)
			}
		case strategy.FieldDropThreshold:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field dropThreshold", values[i])
			} else if value.Valid {
				s.DropThreshold = new(decimal.Decimal)
				*s.DropThreshold = *value.S.(*decimal.Decimal)
			}
		case strategy.FieldEnableAutoBuy:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enableAutoBuy", values[i])
			} else if value.Valid {
				s.EnableAutoBuy = value.Bool
			}
		case strategy.FieldEnableAutoSell:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enableAutoSell", values[i])
			} else if value.Valid {
				s.EnableAutoSell = value.Bool
			}
		case strategy.FieldEnableAutoExit:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enableAutoExit", values[i])
			} else if value.Valid {
				s.EnableAutoExit = value.Bool
			}
		case strategy.FieldEnablePushNotification:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enablePushNotification", values[i])
			} else if value.Valid {
				s.EnablePushNotification = value.Bool
			}
		case strategy.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				s.Status = strategy.Status(value.String)
			}
		case strategy.FieldGridTrend:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field gridTrend", values[i])
			} else if value.Valid {
				s.GridTrend = new(string)
				*s.GridTrend = value.String
			}
		case strategy.FieldLastLowerThresholdAlertTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field lastLowerThresholdAlertTime", values[i])
			} else if value.Valid {
				s.LastLowerThresholdAlertTime = new(time.Time)
				*s.LastLowerThresholdAlertTime = value.Time
			}
		case strategy.FieldLastUpperThresholdAlertTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field lastUpperThresholdAlertTime", values[i])
			} else if value.Valid {
				s.LastUpperThresholdAlertTime = new(time.Time)
				*s.LastUpperThresholdAlertTime = value.Time
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Strategy.
// This includes values selected through modifiers, order, etc.
func (s *Strategy) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// Update returns a builder for updating this Strategy.
// Note that you need to call Strategy.Unwrap() before calling this method if this Strategy
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Strategy) Update() *StrategyUpdateOne {
	return NewStrategyClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Strategy entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Strategy) Unwrap() *Strategy {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Strategy is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Strategy) String() string {
	var builder strings.Builder
	builder.WriteString("Strategy(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("create_time=")
	builder.WriteString(s.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("update_time=")
	builder.WriteString(s.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("guid=")
	builder.WriteString(s.GUID)
	builder.WriteString(", ")
	builder.WriteString("userId=")
	builder.WriteString(fmt.Sprintf("%v", s.UserId))
	builder.WriteString(", ")
	builder.WriteString("token=")
	builder.WriteString(s.Token)
	builder.WriteString(", ")
	builder.WriteString("symbol=")
	builder.WriteString(s.Symbol)
	builder.WriteString(", ")
	builder.WriteString("martinFactor=")
	builder.WriteString(fmt.Sprintf("%v", s.MartinFactor))
	builder.WriteString(", ")
	if v := s.MaxGridLimit; v != nil {
		builder.WriteString("maxGridLimit=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("takeProfitRatio=")
	builder.WriteString(fmt.Sprintf("%v", s.TakeProfitRatio))
	builder.WriteString(", ")
	builder.WriteString("upperPriceBound=")
	builder.WriteString(fmt.Sprintf("%v", s.UpperPriceBound))
	builder.WriteString(", ")
	builder.WriteString("lowerPriceBound=")
	builder.WriteString(fmt.Sprintf("%v", s.LowerPriceBound))
	builder.WriteString(", ")
	builder.WriteString("initialOrderSize=")
	builder.WriteString(fmt.Sprintf("%v", s.InitialOrderSize))
	builder.WriteString(", ")
	if v := s.LastKlineVolume; v != nil {
		builder.WriteString("lastKlineVolume=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.FiveKlineVolume; v != nil {
		builder.WriteString("fiveKlineVolume=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.FirstOrderId; v != nil {
		builder.WriteString("firstOrderId=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.UpperBoundExit; v != nil {
		builder.WriteString("upperBoundExit=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.StopLossExit; v != nil {
		builder.WriteString("stopLossExit=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.TakeProfitExit; v != nil {
		builder.WriteString("takeProfitExit=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := s.GlobalTakeProfitRatio; v != nil {
		builder.WriteString("globalTakeProfitRatio=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("dynamicStopLoss=")
	builder.WriteString(fmt.Sprintf("%v", s.DynamicStopLoss))
	builder.WriteString(", ")
	builder.WriteString("dropOn=")
	builder.WriteString(fmt.Sprintf("%v", s.DropOn))
	builder.WriteString(", ")
	builder.WriteString("candlesToCheck=")
	builder.WriteString(fmt.Sprintf("%v", s.CandlesToCheck))
	builder.WriteString(", ")
	if v := s.DropThreshold; v != nil {
		builder.WriteString("dropThreshold=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("enableAutoBuy=")
	builder.WriteString(fmt.Sprintf("%v", s.EnableAutoBuy))
	builder.WriteString(", ")
	builder.WriteString("enableAutoSell=")
	builder.WriteString(fmt.Sprintf("%v", s.EnableAutoSell))
	builder.WriteString(", ")
	builder.WriteString("enableAutoExit=")
	builder.WriteString(fmt.Sprintf("%v", s.EnableAutoExit))
	builder.WriteString(", ")
	builder.WriteString("enablePushNotification=")
	builder.WriteString(fmt.Sprintf("%v", s.EnablePushNotification))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", s.Status))
	builder.WriteString(", ")
	if v := s.GridTrend; v != nil {
		builder.WriteString("gridTrend=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := s.LastLowerThresholdAlertTime; v != nil {
		builder.WriteString("lastLowerThresholdAlertTime=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := s.LastUpperThresholdAlertTime; v != nil {
		builder.WriteString("lastUpperThresholdAlertTime=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Strategies is a parsable slice of Strategy.
type Strategies []*Strategy
